/* eslint-disable */
/* tslint:disable */
/**
 * This is an autogenerated file created by the Stencil compiler.
 * It contains typing information for all components that exist in this project.
 */
import { HTMLStencilElement, JSXBase } from "@stencil/core/internal";
import { ModusActionBarOptions } from "./components/modus-action-bar/modus-action-bar";
import { ModusAutocompleteOption } from "./components/modus-autocomplete/modus-autocomplete";
import { BadgeProperties } from "./components/modus-badge/modus-badge";
import { Crumb } from "./components/modus-breadcrumb/modus-breadcrumb";
import { ModusDataTableCellLink, ModusDataTableDisplayOptions, ModusDataTableRowAction, ModusDataTableRowActionClickEvent, ModusDataTableSelectionOptions, ModusDataTableSortEvent, ModusDataTableSortOptions, TCell, TColumn, TRow } from "./components/modus-data-table/modus-data-table.models";
import { ModusDateInputEventDetails, ModusDateInputType } from "./components/modus-date-input/utils/modus-date-input.models";
import { ModusIconName } from "./icons/ModusIconUtilities";
import { ModusNavbarApp } from "./components/modus-navbar/apps-menu/modus-navbar-apps-menu";
import { ModusNavbarButton, ModusNavbarLogoOptions, ModusNavbarProfileMenuLink, ModusNavbarTooltip, ModusProfileMenuOptions } from "./components/modus-navbar/modus-navbar.models";
import { ModusNavbarApp as ModusNavbarApp1 } from "./components/modus-navbar/apps-menu/modus-navbar-apps-menu";
import { RadioButton } from "./components/modus-radio-group/modus-radio-button";
import { ModusSentimentScaleType } from "./components/modus-sentiment-scale/modus-sentiment-scale.models";
import { ModusSideNavigationItemInfo } from "./components/modus-side-navigation/modus-side-navigation.models";
import { ModusTableCellEditorArgs, ModusTableCellLink, ModusTableCellValueChange, ModusTableColumn, ModusTableColumnOrderState, ModusTableColumnSizingState, ModusTableColumnSort, ModusTableColumnsVisibilityOptions, ModusTableColumnVisibilityState, ModusTableDisplayOptions, ModusTableExpandedState, ModusTableManualPaginationOptions, ModusTableManualSortingOptions, ModusTablePaginationState, ModusTableRowAction, ModusTableRowActionClick, ModusTableRowSelectionOptions, ModusTableSortingState, ModusTableToolbarOptions } from "./components/modus-table/models/modus-table.models";
import { Cell, Column, Row } from "@tanstack/table-core";
import { TableCellEdited, TableContext } from "./components/modus-table/models/table-context.models";
import { Tab } from "./components/modus-tabs/modus-tabs";
import { ModusTimePickerEventDetails } from "./components/modus-time-picker/modus-time-picker.models";
import { ModusToolTipPlacement } from "./components/modus-tooltip/modus-tooltip.models";
import { ModusActionBarOptions as ModusActionBarOptions1 } from "./components/modus-action-bar/modus-action-bar";
import { TreeViewItemOptions } from "./components/modus-content-tree/modus-content-tree.types";
export { ModusActionBarOptions } from "./components/modus-action-bar/modus-action-bar";
export { ModusAutocompleteOption } from "./components/modus-autocomplete/modus-autocomplete";
export { BadgeProperties } from "./components/modus-badge/modus-badge";
export { Crumb } from "./components/modus-breadcrumb/modus-breadcrumb";
export { ModusDataTableCellLink, ModusDataTableDisplayOptions, ModusDataTableRowAction, ModusDataTableRowActionClickEvent, ModusDataTableSelectionOptions, ModusDataTableSortEvent, ModusDataTableSortOptions, TCell, TColumn, TRow } from "./components/modus-data-table/modus-data-table.models";
export { ModusDateInputEventDetails, ModusDateInputType } from "./components/modus-date-input/utils/modus-date-input.models";
export { ModusIconName } from "./icons/ModusIconUtilities";
export { ModusNavbarApp } from "./components/modus-navbar/apps-menu/modus-navbar-apps-menu";
export { ModusNavbarButton, ModusNavbarLogoOptions, ModusNavbarProfileMenuLink, ModusNavbarTooltip, ModusProfileMenuOptions } from "./components/modus-navbar/modus-navbar.models";
export { ModusNavbarApp as ModusNavbarApp1 } from "./components/modus-navbar/apps-menu/modus-navbar-apps-menu";
export { RadioButton } from "./components/modus-radio-group/modus-radio-button";
export { ModusSentimentScaleType } from "./components/modus-sentiment-scale/modus-sentiment-scale.models";
export { ModusSideNavigationItemInfo } from "./components/modus-side-navigation/modus-side-navigation.models";
export { ModusTableCellEditorArgs, ModusTableCellLink, ModusTableCellValueChange, ModusTableColumn, ModusTableColumnOrderState, ModusTableColumnSizingState, ModusTableColumnSort, ModusTableColumnsVisibilityOptions, ModusTableColumnVisibilityState, ModusTableDisplayOptions, ModusTableExpandedState, ModusTableManualPaginationOptions, ModusTableManualSortingOptions, ModusTablePaginationState, ModusTableRowAction, ModusTableRowActionClick, ModusTableRowSelectionOptions, ModusTableSortingState, ModusTableToolbarOptions } from "./components/modus-table/models/modus-table.models";
export { Cell, Column, Row } from "@tanstack/table-core";
export { TableCellEdited, TableContext } from "./components/modus-table/models/table-context.models";
export { Tab } from "./components/modus-tabs/modus-tabs";
export { ModusTimePickerEventDetails } from "./components/modus-time-picker/modus-time-picker.models";
export { ModusToolTipPlacement } from "./components/modus-tooltip/modus-tooltip.models";
export { ModusActionBarOptions as ModusActionBarOptions1 } from "./components/modus-action-bar/modus-action-bar";
export { TreeViewItemOptions } from "./components/modus-content-tree/modus-content-tree.types";
export namespace Components {
    interface ModusAccordion {
        /**
          * (optional) The accordion's aria-label.
         */
        "ariaLabel": string | null;
    }
    interface ModusAccordionItem {
        /**
          * (optional) Disables the accordion item, locks expand/collapse.
         */
        "disabled": boolean;
        /**
          * (optional) The type of expand button
         */
        "expandButtonType": 'standardArrow' | 'circleArrow';
        /**
          * (optional) Whether the accordion item is expanded.
         */
        "expanded": boolean;
        /**
          * (required) The text to render in the header.
         */
        "headerText": string;
        /**
          * (optional) The icon to display before the header text.
         */
        "icon": string;
        /**
          * (optional) The size of accordion item.
         */
        "size": 'condensed' | 'standard';
    }
    interface ModusActionBar {
        /**
          * (optional) List of actions
         */
        "actions": ModusActionBarOptions[];
        /**
          * (optional) The size of the action items.
         */
        "size": 'small' | 'medium' | 'large';
        /**
          * (optional) Total number of icons to show
         */
        "visibleItemCount": number;
    }
    interface ModusAlert {
        /**
          * (optional) The alert's aria-label.
         */
        "ariaLabel": string | null;
        /**
          * (optional) The button's aria-label.
         */
        "buttonAriaLabel": string | null;
        /**
          * (optional) The button's text
         */
        "buttonText": string | null;
        /**
          * (optional) Whether the alert has a dismiss button
         */
        "dismissible": boolean;
        /**
          * (optional) The alert message
         */
        "message": string;
        /**
          * (optional) The type of alert, sets the color and icon to render
         */
        "type": 'error' | 'info' | 'info-gray' | 'info-gray-dark' | 'success' | 'warning';
    }
    interface ModusAutocomplete {
        /**
          * The autocomplete's aria label.
         */
        "ariaLabel": string | null;
        /**
          * Whether the input has a clear button.
         */
        "clearable": boolean;
        /**
          * Whether the autocomplete's options always display on select.
         */
        "disableCloseOnSelect": boolean;
        /**
          * Whether the input is disabled.
         */
        "disabled": boolean;
        /**
          * The autocomplete's dropdown's max height.
         */
        "dropdownMaxHeight": string;
        /**
          * The autocomplete's dropdown z-index.
         */
        "dropdownZIndex": string;
        /**
          * The autocomplete's error text.
         */
        "errorText": string;
        /**
          * Whether the search icon is included.
         */
        "includeSearchIcon": boolean;
        /**
          * The autocomplete's label.
         */
        "label": string;
        /**
          * When enabled, multiple options can be selected in the component. And selected options are shown as chips in the input.
         */
        "multiple": boolean;
        /**
          * The autocomplete's no results sub-text.
         */
        "noResultsFoundSubtext": string;
        /**
          * The autocomplete's no results text.
         */
        "noResultsFoundText": string;
        /**
          * The autocomplete's options.
         */
        "options": ModusAutocompleteOption[] | string[];
        /**
          * The autocomplete's input placeholder.
         */
        "placeholder": string;
        /**
          * Whether the autocomplete is read-only.
         */
        "readOnly": boolean;
        /**
          * Whether the autocomplete is required.
         */
        "required": boolean;
        /**
          * Whether to show the no results found message.
         */
        "showNoResultsFoundMessage": boolean;
        /**
          * Whether to show autocomplete's options when focus.
         */
        "showOptionsOnFocus": boolean;
        /**
          * The autocomplete's size.
         */
        "size": 'medium' | 'large';
        /**
          * The autocomplete's search value.
         */
        "value": string;
    }
    interface ModusBadge {
        /**
          * (optional) The badge's aria-label
         */
        "ariaLabel": BadgeProperties['ariaLabel'];
        /**
          * (optional) The color of the badge
         */
        "color": BadgeProperties['color'];
        /**
          * (optional) The size of the badge
         */
        "size": BadgeProperties['size'];
        /**
          * (optional) The type of the badge
         */
        "type": BadgeProperties['type'];
    }
    interface ModusBreadcrumb {
        /**
          * The breadcrumb's aria-label.
         */
        "ariaLabel": string | null;
        /**
          * The breadcrumbs to render.
         */
        "crumbs": Crumb[];
        /**
          * (optional) A flag that controls the display of underline
         */
        "underlineLinks": boolean;
    }
    interface ModusButton {
        /**
          * (optional) The button's aria-disabled state.
         */
        "ariaDisabled": string | null;
        /**
          * (optional) The button's aria-label.
         */
        "ariaLabel": string | null;
        /**
          * (optional) The style of the button
         */
        "buttonStyle": 'borderless' | 'fill' | 'outline';
        /**
          * (optional) The color of the button
         */
        "color": 'danger' | 'primary' | 'secondary' | 'tertiary';
        /**
          * (optional) Disables the button.
         */
        "disabled": boolean;
        /**
          * Focus the Button
         */
        "focusButton": () => Promise<void>;
        /**
          * (optional) Takes the icon name and renders an icon-only button.
         */
        "iconOnly": string;
        /**
          * (optional) Takes the icon name and shows the icon aligned to the left of the button text.
         */
        "leftIcon": string;
        /**
          * (optional) Takes the icon name and shows the icon aligned to the right of the button text.
         */
        "rightIcon": string;
        /**
          * (optional) Shows a caret icon right side of the button.
         */
        "showCaret": boolean;
        /**
          * (optional) The size of the button.
         */
        "size": 'small' | 'medium' | 'large';
        /**
          * (Optional) Button types
         */
        "type": 'button' | 'reset' | 'submit';
    }
    interface ModusCard {
        /**
          * (optional) The card's aria-label.
         */
        "ariaLabel": string | null;
        /**
          * (optional) The border radius of the card.
         */
        "borderRadius": string;
        /**
          * (optional) The height of the card.
         */
        "height": string;
        /**
          * (optional) A flag that controls the display of border.
         */
        "showCardBorder": boolean;
        /**
          * (optional) A flag that controls the display of shadow box when the element is hovered.
         */
        "showShadowOnHover": boolean;
        /**
          * (optional) The width of the card.
         */
        "width": string;
    }
    interface ModusCheckbox {
        /**
          * (optional) The checkbox's aria-label.
         */
        "ariaLabel": string | null;
        /**
          * (optional) Whether the checkbox is checked.
         */
        "checked": boolean;
        /**
          * (optional) Whether the checkbox is disabled.
         */
        "disabled": boolean;
        /**
          * Focus the checkbox input
         */
        "focusCheckbox": () => Promise<void>;
        /**
          * (optional) Whether the checkbox is indeterminate.
         */
        "indeterminate": boolean;
        /**
          * (optional) The checkbox label.
         */
        "label": string;
        /**
          * (optional) The size of the checkbox.
         */
        "size": 'small' | 'medium';
        /**
          * (optional) If you wish to prevent the propagation of your event, you may opt for this.
         */
        "stopPropagation": boolean;
        /**
          * (optional) Tab Index for the checkbox
         */
        "tabIndexValue": string | number;
    }
    interface ModusChip {
        /**
          * (optional) The chip's aria-label.
         */
        "ariaLabel": string | null;
        /**
          * (optional) The chip's style.
         */
        "chipStyle": 'outline' | 'solid';
        /**
          * (optional) Whether the chip is disabled.
         */
        "disabled": boolean;
        /**
          * (optional) Whether the chip has an error.
         */
        "hasError": boolean;
        /**
          * (optional) The image's url.
         */
        "imageUrl": string;
        /**
          * (optional) Maximum width for the Chip's text and shows ellipsis when truncated
         */
        "maxWidth": string;
        /**
          * (optional) Whether to show the checkmark.
         */
        "showCheckmark": boolean;
        /**
          * (optional) Whether to show the close icon.
         */
        "showClose": boolean;
        /**
          * (optional) The chip's size.
         */
        "size": 'medium' | 'small';
        /**
          * (optional) The chip's value.
         */
        "value": string;
    }
    interface ModusDataTable {
        "columns": string[] | TColumn[];
        "data": TCell[][] | TRow[];
        /**
          * Options for data table display.
         */
        "displayOptions"?: ModusDataTableDisplayOptions;
        /**
          * Actions that can be performed on each row.
         */
        "rowActions"?: ModusDataTableRowAction[];
        /**
          * Options for data table item selection.
         */
        "selectionOptions"?: ModusDataTableSelectionOptions;
        /**
          * Options for data table column sort.
         */
        "sortOptions"?: ModusDataTableSortOptions;
    }
    interface ModusDateInput {
        /**
          * (optional) Regular expression to allow characters while typing the input.
         */
        "allowedCharsRegex": RegExp | string;
        /**
          * Alternative formats string for the date input split by | separator. Use 'm','mm' for month, 'd','dd' for date and 'yy','yyyy' for year with any separator that is not a regular expression.
         */
        "altFormats": string;
        /**
          * (optional) The input's aria-label.
         */
        "ariaLabel": string | null;
        /**
          * (optional) Sets autofocus on the input.
         */
        "autoFocusInput": boolean;
        /**
          * (optional) Disables default validation for the date input.
         */
        "disableValidation": boolean;
        /**
          * (optional) Whether the input is disabled.
         */
        "disabled": boolean;
        /**
          * (optional) Custom error text displayed for the input.
         */
        "errorText": string;
        /**
          * (optional) Filler date is used as fillers for parts not in the display format when constructing a full date string, for 'value'. It must be in the ISO String format YYYY-MM-DD. Default is {current year}-01-01.
         */
        "fillerDate": string;
        /**
          * Focus the input.
         */
        "focusInput": () => Promise<void>;
        /**
          * Format string for the date input. Default 'mm/dd/yyyy'. Use 'm','mm' for month, 'd','dd' for date and 'yy','yyyy' for year with any separator that is not a regular expression.
         */
        "format": string;
        /**
          * (optional) Custom helper text displayed below the input.
         */
        "helperText": string;
        /**
          * (optional) The input's label.
         */
        "label": string;
        /**
          * (optional) The maximum date allowed. The date is formatted according to ISO8601 'yyyy-mm-dd'.
         */
        "max": string;
        /**
          * (optional) The minimum date allowed. The date is formatted according to ISO8601 'yyyy-mm-dd'.
         */
        "min": string;
        /**
          * (optional) The input's placeholder text.
         */
        "placeholder": string;
        /**
          * (optional) Whether the input's content is read-only
         */
        "readOnly": boolean;
        /**
          * (optional) Whether the input is required.
         */
        "required": boolean;
        /**
          * (optional) Show a calendar icon. Note: Clicking on this icon will only emit an event `calendarIconClicked`.
         */
        "showCalendarIcon": boolean;
        /**
          * (optional) The input's size.
         */
        "size": 'medium' | 'large';
        /**
          * (optional) Denotes what type of date and the types are 'start','end','single'. Required when using `modus-date-picker`.
         */
        "type": ModusDateInputType;
        /**
          * (optional) The input's valid state text.
         */
        "validText": string;
        /**
          * Validate the input.
         */
        "validate": () => Promise<void>;
        /**
          * (optional) A string representing the date entered to the input. The date is formatted according to ISO8601 'yyyy-mm-dd'. The displayed date format will differ from the 'value'.
         */
        "value": string;
    }
    interface ModusDatePicker {
        /**
          * (optional) Label for the field.
         */
        "label": string;
    }
    interface ModusDropdown {
        /**
          * Whether to apply list opening animation.
         */
        "animateList": boolean;
        /**
          * (optional) The dropdown's aria-label.
         */
        "ariaLabel": string | null;
        /**
          * (optional) Determines custom dropdown placement offset.
         */
        "customPlacement": {
    top?: number;
    right?: number;
    bottom?: number;
    left?: number;
  };
        /**
          * (optional) Disables the dropdown.
         */
        "disabled": boolean;
        /**
          * (optional) The placement of the dropdown in related to the toggleElement.
         */
        "placement": 'top' | 'right' | 'bottom' | 'left';
        /**
          * (optional) Whether to show the dropdown list's border.
         */
        "showDropdownListBorder": boolean;
        /**
          * (required) The element id that the list renders near and that triggers the toggling of the list.
         */
        "toggleElementId": string;
    }
    interface ModusFileDropzone {
        /**
          * Add a file to the dropzone.
         */
        "addFile": (file: File) => Promise<void>;
        /**
          * (optional) The dropzone's aria-label.
         */
        "ariaLabel": string | null;
        /**
          * (optional) The dropzone's description text.
         */
        "description": string;
        /**
          * (optional) The dropzone's height.
         */
        "dropzoneHeight": string;
        /**
          * (optional) The dropzone's width.
         */
        "dropzoneWidth": string;
        /**
          * Get the dropzone's error.
         */
        "getError": () => Promise<string | null>;
        /**
          * Get the dropzone's files.
         */
        "getFiles": () => Promise<File[]>;
        /**
          * (optional) Whether to include the upload icon.
         */
        "includeStateIcon": boolean;
        /**
          * (optional) The dropzone's label text.
         */
        "label": string;
        /**
          * (optional) The dropzone's max file count.
         */
        "maxFileCount": number;
        /**
          * (optional) The dropzone's max file name length of each file.
         */
        "maxFileNameLength": number;
        /**
          * (optional) The dropzone's max total file size.
         */
        "maxTotalFileSizeBytes": number;
        /**
          * (optional) Whether multiple files can be uploaded.
         */
        "multiple": boolean;
        /**
          * Remove a file from the dropzone.
         */
        "removeFile": (fileName: string) => Promise<void>;
    }
    interface ModusIcon {
        /**
          * (optional) The color of the Icon
         */
        "color"?: string;
        /**
          * The name of the icon
         */
        "name": ModusIconName | null;
        /**
          * (optional) The size of the Icon
         */
        "size"?: string;
    }
    interface ModusList {
    }
    interface ModusListItem {
        /**
          * (optional) Whether the list item has a border or not
         */
        "borderless": boolean;
        /**
          * (optional) Disables the list item
         */
        "disabled": boolean;
        "focusItem": () => Promise<void>;
        /**
          * (optional) Takes the icon name and shows the icon aligned to the left of the button text.
         */
        "leftIcon": string;
        /**
          * (optional) The selected state of the list item
         */
        "selected": boolean;
        /**
          * (optional) The size of list item
         */
        "size": 'condensed' | 'large' | 'standard';
        /**
          * (optional) Whether to show Subtext below the Slot content or not
         */
        "subText": string;
        /**
          * (optional) The type of list item
         */
        "type": string;
        /**
          * (optional) Whether to wrap the sub text.
         */
        "wrapSubText": true | false;
    }
    interface ModusMessage {
        /**
          * (optional) The message's aria-label.
         */
        "ariaLabel": string | null;
        /**
          * (optional) The message's icon.
         */
        "icon"?: string;
        /**
          * (optional) The message's type.
         */
        "type"?: 'info' | 'question';
    }
    interface ModusModal {
        /**
          * (optional) The modal's aria-label.
         */
        "ariaLabel": string | null;
        /**
          * (optional) The modal's backdrop. Specify 'static' for a backdrop that doesn't close the modal when clicked outside the modal content
         */
        "backdrop": 'default' | 'static';
        /**
          * Closes the Modal
         */
        "close": () => Promise<void>;
        /**
          * (optional) The modal's primary button text.
         */
        "headerText": string;
        /**
          * Opens the Modal
         */
        "open": () => Promise<void>;
        /**
          * (optional) The modal's primary button aria-label.
         */
        "primaryButtonAriaLabel": string | null;
        /**
          * (optional) Disable primary button.
         */
        "primaryButtonDisabled": boolean;
        /**
          * (optional) The modal's primary button text.
         */
        "primaryButtonText": string;
        /**
          * (optional) The modal's secondary button aria-label.
         */
        "secondaryButtonAriaLabel": string | null;
        /**
          * (optional) Disable secondary button.
         */
        "secondaryButtonDisabled": boolean;
        /**
          * (optional) The modal's secondary button text.
         */
        "secondaryButtonText": string;
        /**
          * (optional) The modal's z-index.
         */
        "zIndex": string;
    }
    interface ModusNavbar {
        /**
          * (optional) The apps to render in the apps menu.
         */
        "apps": ModusNavbarApp[];
        /**
          * (optional) The buttons to render in the Navbar.
         */
        "buttons": ModusNavbarButton[];
        /**
          * (optional) Whether to show search overlay or not.
         */
        "enableSearchOverlay": boolean;
        /**
          * (optional) Help tooltip.
         */
        "helpTooltip": ModusNavbarTooltip;
        /**
          * (optional) Help URL.
         */
        "helpUrl": string;
        "hideMainMenu": () => Promise<void>;
        /**
          * (optional) Set the primary logo to display when the screen size is greater than 576 pixels, and the secondary logo to display when the screen size is less than or equal to 576 pixels.
         */
        "logoOptions": ModusNavbarLogoOptions;
        /**
          * (required) Profile menu options.
         */
        "profileMenuOptions": ModusProfileMenuOptions;
        /**
          * (optional) Whether to display the navbar items in reverse order.
         */
        "reverse": boolean;
        /**
          * (optional) Search tooltip.
         */
        "searchTooltip": ModusNavbarTooltip;
        /**
          * (optional) Whether to show the apps menu.
         */
        "showAppsMenu": boolean;
        /**
          * (optional) Whether to show help.
         */
        "showHelp": boolean;
        /**
          * (optional) Whether to show the main menu.
         */
        "showMainMenu": boolean;
        /**
          * (optional) Whether to show notifications.
         */
        "showNotifications": boolean;
        /**
          * (optional) Whether to show the placeholder for Pendo.
         */
        "showPendoPlaceholder": boolean;
        /**
          * (optional) Whether to show profile.  *
         */
        "showProfile": boolean;
        /**
          * (optional) Whether to show search.
         */
        "showSearch": boolean;
        /**
          * (optional) Whether to show a shadow under the navbar.
         */
        "showShadow": boolean;
        /**
          * (optional) Color variants for NavBar.
         */
        "variant": 'default' | 'blue';
    }
    interface ModusNavbarAppsMenu {
        "apps": ModusNavbarApp1[];
        "reverse": boolean;
    }
    interface ModusNavbarButtonMenu {
        "reverse": boolean;
    }
    interface ModusNavbarMainMenu {
        "navbarId": string;
    }
    interface ModusNavbarNotificationsMenu {
        "reverse": boolean;
    }
    interface ModusNavbarProfileMenu {
        "avatarUrl": string;
        "email": string;
        "initials": string;
        "links": ModusNavbarProfileMenuLink[];
        "reverse": boolean;
        "signOutText": string;
        "username": string;
        "variant": 'default' | 'blue';
    }
    interface ModusNavbarSearchOverlay {
    }
    interface ModusNumberInput {
        /**
          * (optional) The input's aria-label.
         */
        "ariaLabel": string | null;
        /**
          * (optional) Whether the input is disabled.
         */
        "disabled": boolean;
        /**
          * (optional) The input's error state text.
         */
        "errorText": string;
        /**
          * Focus the input.
         */
        "focusInput": () => Promise<void>;
        /**
          * (optional) The input's helper text displayed below the input.
         */
        "helperText": string;
        /**
          * (optional) The input's label.
         */
        "label": string;
        /**
          * (optional) The input's maximum value.
         */
        "maxValue": number;
        /**
          * (optional) The input's minimum value.
         */
        "minValue": number;
        /**
          * (optional) The input's placeholder text.
         */
        "placeholder": string;
        /**
          * (optional) Whether the input's content is read-only
         */
        "readOnly": boolean;
        /**
          * (optional) Whether the input is required.
         */
        "required": boolean;
        /**
          * (optional) The input's size.
         */
        "size": 'medium' | 'large';
        /**
          * (optional) The input's step.
         */
        "step": number;
        /**
          * (optional) The input's text alignment.
         */
        "textAlign": 'left' | 'right';
        /**
          * (optional) The input's valid state text.
         */
        "validText": string;
        /**
          * (optional) The input's value.
         */
        "value": string;
    }
    interface ModusPagination {
        "activePage": number;
        "ariaLabel": string | null;
        "maxPage": number;
        "minPage": number;
        "nextPageButtonText"?: string;
        "prevPageButtonText"?: string;
        "size": 'large' | 'medium' | 'small';
    }
    interface ModusProgressBar {
        /**
          * (optional) The progress bar's aria-label.
         */
        "ariaLabel": string | null;
        /**
          * (optional) The progress bar's background color.
         */
        "backgroundColor": string;
        /**
          * (optional) The progress bar's foreground color.
         */
        "color": string;
        /**
          * (optional) The progress bar's maximum value.
         */
        "maxValue": number;
        /**
          * (optional) The progress bar's minimum value.
         */
        "minValue": number;
        /**
          * (optional) The progress bar's size.
         */
        "size": 'default' | 'small' | 'compact';
        /**
          * (optional) The text displayed on the progress bar.
         */
        "text": string;
        /**
          * (optional) The progress bar's text color.
         */
        "textColor": string;
        /**
          * (optional) The progress bar's value.
         */
        "value": number;
    }
    interface ModusRadioGroup {
        /**
          * The radio group's aria-label.
         */
        "ariaLabel": string | null;
        /**
          * The ID of the checked radio button.
         */
        "checkedId": string;
        /**
          * The radio button group name.
         */
        "name": string;
        /**
          * The radio buttons to render.
         */
        "radioButtons": RadioButton[];
        /**
          * (optional) The size of the radiobutton.
         */
        "size"?: 'small' | 'medium';
    }
    interface ModusSelect {
        /**
          * (optional) The select's aria-label.
         */
        "ariaLabel": string | null;
        /**
          * (optional) Whether the input is disabled.
         */
        "disabled": boolean;
        /**
          * (optional) The input's error text.
         */
        "errorText": string;
        /**
          * Focus the input.
         */
        "focusInput": () => Promise<void>;
        /**
          * (optional) The input's helper text.
         */
        "helperText": string;
        /**
          * (optional) The input label.
         */
        "label": string;
        /**
          * The options for the dropdown list.
         */
        "options": unknown[];
        /**
          * The options property to render in the dropdown list.
         */
        "optionsDisplayProp": string;
        /**
          * (optional) The input's placeholder.
         */
        "placeholder": string;
        /**
          * (optional) Whether the input is required.
         */
        "required": boolean;
        /**
          * (optional) The input's size.
         */
        "size": 'medium' | 'large';
        /**
          * (optional) The input's valid text.
         */
        "validText": string;
        /**
          * (optional) The input value.
         */
        "value": unknown;
    }
    interface ModusSentimentScale {
        /**
          * (optional) The sentiment scale's aria-label.
         */
        "ariaLabel": string | null;
        /**
          * (optional) Whether the sentiment scale is disabled.
         */
        "disabled"?: boolean;
        /**
          * The type of icons to be displayed.
         */
        "type": ModusSentimentScaleType;
    }
    interface ModusSideNavigation {
        /**
          * (optional) To choose whether to collapse the panel when clicked outside.
         */
        "collapseOnClickOutside": boolean;
        /**
          * (optional) Data property to create the items.
         */
        "data": ModusSideNavigationItemInfo[];
        /**
          * (optional) The expanded state of side navigation panel and items.
         */
        "expanded": boolean;
        /**
          * (optional) Maximum width of the side navigation panel in an expanded state.
         */
        "maxWidth": string;
        /**
          * Mode to make side navigation either overlay or push the content for the selector specified in `targetContent`
         */
        "mode": 'overlay' | 'push';
        /**
          * (optional) Specify the selector for the page's content for which paddings and margins will be set by side navigation based on the `mode`.
         */
        "targetContent": string;
    }
    interface ModusSideNavigationItem {
        /**
          * (optional) Disables item selection.
         */
        "disableSelection": boolean;
        /**
          * (optional) The disabled state of side navigation panel item.
         */
        "disabled": boolean;
        "expanded": boolean;
        "focusItem": () => Promise<void>;
        /**
          * (optional) Label for the item and the tooltip message.
         */
        "label": string;
        /**
          * (optional) A built-in menu icon string or a image url.
         */
        "menuIcon": string;
        /**
          * (optional) The selected state of side navigation panel item.
         */
        "selected": boolean;
        /**
          * (optional) Shows the expand icon.
         */
        "showExpandIcon": boolean;
    }
    interface ModusSlider {
        /**
          * (optional) The slider's aria-label.
         */
        "ariaLabel": string | null;
        /**
          * (optional) Whether the slider is disabled. *
         */
        "disabled": boolean;
        /**
          * (optional) The slider's label.
         */
        "label": string;
        /**
          * (optional) The slider's maximum value.
         */
        "maxValue": number;
        /**
          * (optional) The slider's minimum value.
         */
        "minValue": number;
        /**
          * (optional) The slider's value.
         */
        "value": string;
    }
    interface ModusSpinner {
        /**
          * (optional) The color of the spinner. It can be a custom color or one of the variants  - primary, secondary, tertiary, dark, success, danger and warning.
         */
        "color": string;
        /**
          * (optional) The size of the spinner, will be applied to both the height and width
         */
        "size": string;
    }
    interface ModusSwitch {
        /**
          * (optional) The switch's aria-label.
         */
        "ariaLabel": string | null;
        /**
          * (optional) Whether the switch is checked.
         */
        "checked": boolean;
        /**
          * (optional) Whether the switch is disabled.
         */
        "disabled": boolean;
        /**
          * (optional) The switch label.
         */
        "label": string;
        /**
          * (optional) The size of the radiobutton.
         */
        "size"?: 'small' | 'medium';
    }
    interface ModusTable {
        /**
          * (Optional) To allow column reordering.
         */
        "columnReorder": boolean;
        "columnResize": boolean;
        /**
          * (Required) To display headers in the table.
         */
        "columns": ModusTableColumn<unknown>[];
        /**
          * (Required) To display data in the table.
         */
        "data": unknown[];
        /**
          * (Optional) To set the default sorting for the table.
         */
        "defaultSort": ModusTableColumnSort;
        /**
          * (optional) The density of the table.
         */
        "density": 'relaxed' | 'comfortable' | 'compact';
        /**
          * (Optional) To control display options of table.
         */
        "displayOptions"?: ModusTableDisplayOptions;
        "fullWidth": boolean;
        /**
          * Returns data of a column.
          * @param accessorKey : Column name as key.
          * @returns : Column data as Array or empty array.
         */
        "getColumnData": (accessorKey: string) => Promise<unknown[]>;
        /**
          * (Optional) To enable row hover in table.
         */
        "hover": boolean;
        /**
          * (Optional) To enable manual pagination mode. When enabled, the table will not automatically paginate rows, instead will expect the current page index and other details to be passed.
         */
        "manualPaginationOptions": ModusTableManualPaginationOptions;
        /**
          * (Optional) To set modus-table in manual sorting mode.
         */
        "manualSortingOptions": ModusTableManualSortingOptions;
        /**
          * (Optional) To display a vertical scrollbar when the height is exceeded.
         */
        "maxHeight": string;
        /**
          * (Optional) To display a horizontal scrollbar when the width is exceeded.
         */
        "maxWidth": string;
        "pageSizeList": number[];
        "pagination": boolean;
        /**
          * (Optional) Actions that can be performed on each row. A maximum of 4 icons will be shown, including overflow menu and expand icons.
         */
        "rowActions": ModusTableRowAction[];
        /**
          * (Optional) To display checkbox.
         */
        "rowSelection": boolean;
        /**
          * (Optional) To control multiple row selection.
         */
        "rowSelectionOptions": ModusTableRowSelectionOptions;
        /**
          * (Optional) To display expanded rows.
         */
        "rowsExpandable": boolean;
        /**
          * (Optional) To display sort icon on hover.
         */
        "showSortIconOnHover": boolean;
        /**
          * (Optional) To sort data in table.
         */
        "sort": boolean;
        /**
          * (Optional) To display a-z or arrow sort icons.
         */
        "sortIconStyle": 'alphabetical' | 'directional';
        /**
          * (Optional) To display summary row.
         */
        "summaryRow": boolean;
        /**
          * Toggle the table column visibility
          * @param columnId Column id
          * @param show Boolean value decides to visibility of column
         */
        "toggleColumnVisibility": (columnId: string, show: boolean) => Promise<void>;
        /**
          * (Optional) To display a toolbar for the table.
         */
        "toolbar": boolean;
        /**
          * (Optional) To display a toolbar, which allows access to table operations like hiding columns.
         */
        "toolbarOptions": ModusTableToolbarOptions | null;
        /**
          * (Optional) To wrap text that overflows the cell.
         */
        "wrapText": boolean;
    }
    interface ModusTableCellEditor {
        "args": ModusTableCellEditorArgs;
        "keyDown": (e: KeyboardEvent, newValue: string) => void;
        "type": string;
        "value": string;
        "valueChange": (newValue: string) => void;
    }
    interface ModusTableCellMain {
        "cell": Cell<unknown, unknown>;
        "context": TableContext;
        "hasRowsExpandable": boolean;
        "valueChange": (props: TableCellEdited) => void;
    }
    interface ModusTableColumnsVisibility {
        /**
          * Column visibility options
         */
        "columnsVisibility": ModusTableColumnsVisibilityOptions;
        /**
          * Table data.
         */
        "getAllLeafColumns": () => Column<unknown, unknown>[];
        "maxHeight": string;
        "menuIconContainerRef": HTMLDivElement;
        "showDropdown": boolean;
        "toggleDropdown": (show: boolean) => void;
    }
    interface ModusTableDropdownMenu {
        "context": TableContext;
    }
    /**
     * ModusFillerColumn is to fill empty space within a table or grid when the content in other columns is not wide enough to occupy the entire available width
     */
    interface ModusTableFillerColumn {
        "cellBorderless": boolean;
        "container"?: HTMLElement;
        "summaryRow": boolean;
    }
    interface ModusTableRowActions {
        "context": TableContext;
        "row": Row<unknown>;
    }
    interface ModusTableRowActionsCell {
        "context": TableContext;
        "row": Row<unknown>;
    }
    interface ModusTableRowActionsMenu {
        "context": TableContext;
    }
    interface ModusTableToolbar {
        /**
          * Table data.
         */
        "context": TableContext;
    }
    interface ModusTabs {
        "ariaLabel": string | null;
        "fullWidth": boolean;
        "size": 'medium' | 'small';
        /**
          * The tabs to render.
         */
        "tabs": Tab[];
    }
    interface ModusTextInput {
        /**
          * (optional) The input's aria-label.
         */
        "ariaLabel": string | null;
        /**
          * (optional) Sets autofocus on the input.
         */
        "autoFocusInput": boolean;
        /**
          * (optional) Sets autocomplete on the input.
         */
        "autocomplete": string | null;
        /**
          * (optional) Whether the input has a clear button.
         */
        "clearable": boolean;
        /**
          * (optional) Whether the input is disabled.
         */
        "disabled": boolean;
        /**
          * (optional) The input's error state text.
         */
        "errorText": string;
        /**
          * Focus the input.
         */
        "focusInput": () => Promise<void>;
        /**
          * (optional) The input's helper text displayed below the input.
         */
        "helperText": string;
        /**
          * (optional) Whether the password text toggle icon is included.
         */
        "includePasswordTextToggle": boolean;
        /**
          * (optional) Whether the search icon is included.
         */
        "includeSearchIcon": boolean;
        /**
          * (optional) The input's inputmode.
         */
        "inputmode": 'decimal' | 'email' | 'numeric' | 'search' | 'tel' | 'text' | 'url';
        /**
          * (optional) The input's label.
         */
        "label": string;
        /**
          * (optional) The input's maximum length.
         */
        "maxLength": number;
        /**
          * (optional) The input's minimum length.
         */
        "minLength": number;
        /**
          * (optional) The input's pattern HTML attribute.
         */
        "pattern": string;
        /**
          * (optional) The input's placeholder text.
         */
        "placeholder": string;
        /**
          * (optional) Whether the input's content is read-only
         */
        "readOnly": boolean;
        /**
          * (optional) Whether the input is required.
         */
        "required": boolean;
        /**
          * (optional) The input's size.
         */
        "size": 'medium' | 'large';
        /**
          * (optional) The input's text alignment.
         */
        "textAlign": 'left' | 'right';
        /**
          * (optional) The input's type.
         */
        "type": 'email' | 'password' | 'search' | 'text' | 'tel' | 'url';
        /**
          * (optional) The input's valid state text.
         */
        "validText": string;
        /**
          * (optional) The input's value.
         */
        "value": string;
    }
    interface ModusTimePicker {
        /**
          * (optional) Regular expression to allow characters while typing the input. Default is `/[\d:apm\s]/gi` or `/[\d:]/gi` based on the display format.
         */
        "allowedCharsRegex": RegExp | string;
        /**
          * (optional) Sets 12/24 hour format for the input string.
         */
        "ampm": boolean;
        /**
          * (optional) The input's aria-label.
         */
        "ariaLabel": string | null;
        /**
          * (optional) Sets autofocus on the input.
         */
        "autoFocusInput": boolean;
        /**
          * (optional) Formats the text while typing in the input field.
         */
        "autoFormat": boolean;
        /**
          * (optional) Disables default validation for the time input.
         */
        "disableValidation": boolean;
        /**
          * (optional) Whether the input is disabled.
         */
        "disabled": boolean;
        /**
          * (optional) Custom error text displayed for the input.
         */
        "errorText": string;
        /**
          * Focus the input.
         */
        "focusInput": () => Promise<void>;
        /**
          * (optional) Custom helper text displayed below the input.
         */
        "helperText": string;
        /**
          * (optional) The input's label.
         */
        "label": string;
        /**
          * (optional) Maximum time (in 24 hour format).
         */
        "max": string;
        /**
          * (optional) Minimum time (in 24 hour format).
         */
        "min": string;
        /**
          * (optional) The input's placeholder text.
         */
        "placeholder": string;
        /**
          * (optional) Whether the input's content is read-only
         */
        "readOnly": boolean;
        /**
          * (optional) Whether the input is required.
         */
        "required": boolean;
        /**
          * (optional) The input's size.
         */
        "size": 'medium' | 'large';
        /**
          * (optional) The input's valid state text.
         */
        "validText": string;
        /**
          * (optional) Value of the time entered into the input.
         */
        "value": string;
    }
    interface ModusToast {
        /**
          * (optional) The toast's aria-label.
         */
        "ariaLabel": string | null;
        /**
          * (optional) Whether the toast has a dismiss button.
         */
        "dismissible": boolean;
        /**
          * (optional) Whether to show the toasts' icon.
         */
        "showIcon": boolean;
        /**
          * (optional) The toasts' type.
         */
        "type": 'danger' | 'dark' | 'default' | 'primary' | 'secondary' | 'success' | 'warning';
    }
    interface ModusTooltip {
        /**
          * (optional) The tooltip's aria-label.
         */
        "ariaLabel": string | null;
        /**
          * Hide the tooltip
         */
        "disabled": boolean;
        /**
          * (optional) The tooltip's position relative to its content.
         */
        "position": ModusToolTipPlacement;
        /**
          * The tooltip's text.
         */
        "text": string;
    }
    interface ModusTreeView {
        /**
          * (optional) Whether the content tree and items have a border or not
         */
        "borderless": boolean;
        /**
          * (optional) Enables checkbox selection on each tree item
         */
        "checkboxSelection": boolean;
        /**
          * (optional) Set checked tree items
         */
        "checkedItems": string[];
        /**
          * (optional) Disable usage of `tab` key to focus elements inside a tree view. Use `Arrow Up/Down` for focussing a tree item and `Shift + Arrow Right` for focussing a checkbox inside the item.
         */
        "disableTabbing": boolean;
        /**
          * (optional) Set expanded tree items
         */
        "expandedItems": string[];
        /**
          * (optional) Enables multiple checkbox selection
         */
        "multiCheckboxSelection": boolean;
        /**
          * (optional) Enables multiple tree items selection
         */
        "multiSelection": boolean;
        /**
          * (optional) Set selected tree items
         */
        "selectedItems": string[];
        /**
          * (optional) The default size of all tree items
         */
        "size": 'condensed' | 'large' | 'standard';
    }
    interface ModusTreeViewItem {
        /**
          * (optional) Actions that can be performed on each item. A maximum of 3 icons will be shown, including overflow menu and expand icons.
         */
        "actions": ModusActionBarOptions1[];
        /**
          * (optional) Disables the tree item
         */
        "disabled": boolean;
        /**
          * (optional) Allows the item to be dragged across the tree
         */
        "draggableItem": boolean;
        /**
          * (optional) Allows the item to be a drop zone so other tree items can be dropped above it
         */
        "droppableItem": boolean;
        /**
          * (optional) Changes the label field into a text box
         */
        "editable": boolean;
        /**
          * Focus the checkbox inside a tree item
         */
        "focusCheckbox": () => Promise<void>;
        /**
          * Focus the tree item
         */
        "focusItem": () => Promise<void>;
        "initTreeViewItem": (newValue: TreeViewItemOptions) => Promise<void>;
        /**
          * (required) Label for the tree item
         */
        "label": string;
        /**
          * (required) Unique tree item identifier
         */
        "nodeId": string;
        /**
          * (optional) Tab Index for the tree item
         */
        "tabIndexValue": string | number;
        "updateComponent": () => Promise<void>;
    }
}
export interface ModusAccordionItemCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLModusAccordionItemElement;
}
export interface ModusActionBarCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLModusActionBarElement;
}
export interface ModusAlertCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLModusAlertElement;
}
export interface ModusAutocompleteCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLModusAutocompleteElement;
}
export interface ModusBreadcrumbCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLModusBreadcrumbElement;
}
export interface ModusButtonCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLModusButtonElement;
}
export interface ModusCheckboxCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLModusCheckboxElement;
}
export interface ModusChipCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLModusChipElement;
}
export interface ModusDataTableCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLModusDataTableElement;
}
export interface ModusDateInputCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLModusDateInputElement;
}
export interface ModusDropdownCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLModusDropdownElement;
}
export interface ModusFileDropzoneCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLModusFileDropzoneElement;
}
export interface ModusIconCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLModusIconElement;
}
export interface ModusListItemCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLModusListItemElement;
}
export interface ModusModalCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLModusModalElement;
}
export interface ModusNavbarCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLModusNavbarElement;
}
export interface ModusNavbarAppsMenuCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLModusNavbarAppsMenuElement;
}
export interface ModusNavbarProfileMenuCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLModusNavbarProfileMenuElement;
}
export interface ModusNavbarSearchOverlayCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLModusNavbarSearchOverlayElement;
}
export interface ModusNumberInputCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLModusNumberInputElement;
}
export interface ModusPaginationCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLModusPaginationElement;
}
export interface ModusRadioGroupCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLModusRadioGroupElement;
}
export interface ModusSelectCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLModusSelectElement;
}
export interface ModusSentimentScaleCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLModusSentimentScaleElement;
}
export interface ModusSideNavigationCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLModusSideNavigationElement;
}
export interface ModusSideNavigationItemCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLModusSideNavigationItemElement;
}
export interface ModusSliderCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLModusSliderElement;
}
export interface ModusSwitchCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLModusSwitchElement;
}
export interface ModusTableCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLModusTableElement;
}
export interface ModusTableRowActionsCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLModusTableRowActionsElement;
}
export interface ModusTabsCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLModusTabsElement;
}
export interface ModusTextInputCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLModusTextInputElement;
}
export interface ModusTimePickerCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLModusTimePickerElement;
}
export interface ModusToastCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLModusToastElement;
}
export interface ModusTreeViewCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLModusTreeViewElement;
}
export interface ModusTreeViewItemCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLModusTreeViewItemElement;
}
declare global {
    interface HTMLModusAccordionElement extends Components.ModusAccordion, HTMLStencilElement {
    }
    var HTMLModusAccordionElement: {
        prototype: HTMLModusAccordionElement;
        new (): HTMLModusAccordionElement;
    };
    interface HTMLModusAccordionItemElementEventMap {
        "closed": any;
        "opened": any;
    }
    interface HTMLModusAccordionItemElement extends Components.ModusAccordionItem, HTMLStencilElement {
        addEventListener<K extends keyof HTMLModusAccordionItemElementEventMap>(type: K, listener: (this: HTMLModusAccordionItemElement, ev: ModusAccordionItemCustomEvent<HTMLModusAccordionItemElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLModusAccordionItemElementEventMap>(type: K, listener: (this: HTMLModusAccordionItemElement, ev: ModusAccordionItemCustomEvent<HTMLModusAccordionItemElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLModusAccordionItemElement: {
        prototype: HTMLModusAccordionItemElement;
        new (): HTMLModusAccordionItemElement;
    };
    interface HTMLModusActionBarElementEventMap {
        "actionBarClick": any;
    }
    interface HTMLModusActionBarElement extends Components.ModusActionBar, HTMLStencilElement {
        addEventListener<K extends keyof HTMLModusActionBarElementEventMap>(type: K, listener: (this: HTMLModusActionBarElement, ev: ModusActionBarCustomEvent<HTMLModusActionBarElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLModusActionBarElementEventMap>(type: K, listener: (this: HTMLModusActionBarElement, ev: ModusActionBarCustomEvent<HTMLModusActionBarElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLModusActionBarElement: {
        prototype: HTMLModusActionBarElement;
        new (): HTMLModusActionBarElement;
    };
    interface HTMLModusAlertElementEventMap {
        "dismissClick": any;
        "actionClick": any;
    }
    interface HTMLModusAlertElement extends Components.ModusAlert, HTMLStencilElement {
        addEventListener<K extends keyof HTMLModusAlertElementEventMap>(type: K, listener: (this: HTMLModusAlertElement, ev: ModusAlertCustomEvent<HTMLModusAlertElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLModusAlertElementEventMap>(type: K, listener: (this: HTMLModusAlertElement, ev: ModusAlertCustomEvent<HTMLModusAlertElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLModusAlertElement: {
        prototype: HTMLModusAlertElement;
        new (): HTMLModusAlertElement;
    };
    interface HTMLModusAutocompleteElementEventMap {
        "optionSelected": string;
        "valueChange": string;
    }
    interface HTMLModusAutocompleteElement extends Components.ModusAutocomplete, HTMLStencilElement {
        addEventListener<K extends keyof HTMLModusAutocompleteElementEventMap>(type: K, listener: (this: HTMLModusAutocompleteElement, ev: ModusAutocompleteCustomEvent<HTMLModusAutocompleteElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLModusAutocompleteElementEventMap>(type: K, listener: (this: HTMLModusAutocompleteElement, ev: ModusAutocompleteCustomEvent<HTMLModusAutocompleteElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLModusAutocompleteElement: {
        prototype: HTMLModusAutocompleteElement;
        new (): HTMLModusAutocompleteElement;
    };
    interface HTMLModusBadgeElement extends Components.ModusBadge, HTMLStencilElement {
    }
    var HTMLModusBadgeElement: {
        prototype: HTMLModusBadgeElement;
        new (): HTMLModusBadgeElement;
    };
    interface HTMLModusBreadcrumbElementEventMap {
        "crumbClick": Crumb;
    }
    interface HTMLModusBreadcrumbElement extends Components.ModusBreadcrumb, HTMLStencilElement {
        addEventListener<K extends keyof HTMLModusBreadcrumbElementEventMap>(type: K, listener: (this: HTMLModusBreadcrumbElement, ev: ModusBreadcrumbCustomEvent<HTMLModusBreadcrumbElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLModusBreadcrumbElementEventMap>(type: K, listener: (this: HTMLModusBreadcrumbElement, ev: ModusBreadcrumbCustomEvent<HTMLModusBreadcrumbElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLModusBreadcrumbElement: {
        prototype: HTMLModusBreadcrumbElement;
        new (): HTMLModusBreadcrumbElement;
    };
    interface HTMLModusButtonElementEventMap {
        "buttonClick": any;
    }
    interface HTMLModusButtonElement extends Components.ModusButton, HTMLStencilElement {
        addEventListener<K extends keyof HTMLModusButtonElementEventMap>(type: K, listener: (this: HTMLModusButtonElement, ev: ModusButtonCustomEvent<HTMLModusButtonElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLModusButtonElementEventMap>(type: K, listener: (this: HTMLModusButtonElement, ev: ModusButtonCustomEvent<HTMLModusButtonElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLModusButtonElement: {
        prototype: HTMLModusButtonElement;
        new (): HTMLModusButtonElement;
    };
    interface HTMLModusCardElement extends Components.ModusCard, HTMLStencilElement {
    }
    var HTMLModusCardElement: {
        prototype: HTMLModusCardElement;
        new (): HTMLModusCardElement;
    };
    interface HTMLModusCheckboxElementEventMap {
        "checkboxClick": boolean;
    }
    interface HTMLModusCheckboxElement extends Components.ModusCheckbox, HTMLStencilElement {
        addEventListener<K extends keyof HTMLModusCheckboxElementEventMap>(type: K, listener: (this: HTMLModusCheckboxElement, ev: ModusCheckboxCustomEvent<HTMLModusCheckboxElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLModusCheckboxElementEventMap>(type: K, listener: (this: HTMLModusCheckboxElement, ev: ModusCheckboxCustomEvent<HTMLModusCheckboxElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLModusCheckboxElement: {
        prototype: HTMLModusCheckboxElement;
        new (): HTMLModusCheckboxElement;
    };
    interface HTMLModusChipElementEventMap {
        "chipClick": any;
        "closeClick": any;
    }
    interface HTMLModusChipElement extends Components.ModusChip, HTMLStencilElement {
        addEventListener<K extends keyof HTMLModusChipElementEventMap>(type: K, listener: (this: HTMLModusChipElement, ev: ModusChipCustomEvent<HTMLModusChipElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLModusChipElementEventMap>(type: K, listener: (this: HTMLModusChipElement, ev: ModusChipCustomEvent<HTMLModusChipElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLModusChipElement: {
        prototype: HTMLModusChipElement;
        new (): HTMLModusChipElement;
    };
    interface HTMLModusDataTableElementEventMap {
        "cellLinkClick": ModusDataTableCellLink;
        "rowDoubleClick": string;
        "selection": string[];
        "sort": ModusDataTableSortEvent;
        "rowActionClick": ModusDataTableRowActionClickEvent;
    }
    interface HTMLModusDataTableElement extends Components.ModusDataTable, HTMLStencilElement {
        addEventListener<K extends keyof HTMLModusDataTableElementEventMap>(type: K, listener: (this: HTMLModusDataTableElement, ev: ModusDataTableCustomEvent<HTMLModusDataTableElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLModusDataTableElementEventMap>(type: K, listener: (this: HTMLModusDataTableElement, ev: ModusDataTableCustomEvent<HTMLModusDataTableElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLModusDataTableElement: {
        prototype: HTMLModusDataTableElement;
        new (): HTMLModusDataTableElement;
    };
    interface HTMLModusDateInputElementEventMap {
        "calendarIconClicked": ModusDateInputEventDetails;
        "dateInputBlur": ModusDateInputEventDetails;
        "valueChange": ModusDateInputEventDetails;
    }
    interface HTMLModusDateInputElement extends Components.ModusDateInput, HTMLStencilElement {
        addEventListener<K extends keyof HTMLModusDateInputElementEventMap>(type: K, listener: (this: HTMLModusDateInputElement, ev: ModusDateInputCustomEvent<HTMLModusDateInputElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLModusDateInputElementEventMap>(type: K, listener: (this: HTMLModusDateInputElement, ev: ModusDateInputCustomEvent<HTMLModusDateInputElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLModusDateInputElement: {
        prototype: HTMLModusDateInputElement;
        new (): HTMLModusDateInputElement;
    };
    interface HTMLModusDatePickerElement extends Components.ModusDatePicker, HTMLStencilElement {
    }
    var HTMLModusDatePickerElement: {
        prototype: HTMLModusDatePickerElement;
        new (): HTMLModusDatePickerElement;
    };
    interface HTMLModusDropdownElementEventMap {
        "dropdownClose": any;
    }
    interface HTMLModusDropdownElement extends Components.ModusDropdown, HTMLStencilElement {
        addEventListener<K extends keyof HTMLModusDropdownElementEventMap>(type: K, listener: (this: HTMLModusDropdownElement, ev: ModusDropdownCustomEvent<HTMLModusDropdownElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLModusDropdownElementEventMap>(type: K, listener: (this: HTMLModusDropdownElement, ev: ModusDropdownCustomEvent<HTMLModusDropdownElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLModusDropdownElement: {
        prototype: HTMLModusDropdownElement;
        new (): HTMLModusDropdownElement;
    };
    interface HTMLModusFileDropzoneElementEventMap {
        "files": [File[], string | null];
    }
    interface HTMLModusFileDropzoneElement extends Components.ModusFileDropzone, HTMLStencilElement {
        addEventListener<K extends keyof HTMLModusFileDropzoneElementEventMap>(type: K, listener: (this: HTMLModusFileDropzoneElement, ev: ModusFileDropzoneCustomEvent<HTMLModusFileDropzoneElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLModusFileDropzoneElementEventMap>(type: K, listener: (this: HTMLModusFileDropzoneElement, ev: ModusFileDropzoneCustomEvent<HTMLModusFileDropzoneElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLModusFileDropzoneElement: {
        prototype: HTMLModusFileDropzoneElement;
        new (): HTMLModusFileDropzoneElement;
    };
    interface HTMLModusIconElementEventMap {
        "iconClick": any;
    }
    interface HTMLModusIconElement extends Components.ModusIcon, HTMLStencilElement {
        addEventListener<K extends keyof HTMLModusIconElementEventMap>(type: K, listener: (this: HTMLModusIconElement, ev: ModusIconCustomEvent<HTMLModusIconElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLModusIconElementEventMap>(type: K, listener: (this: HTMLModusIconElement, ev: ModusIconCustomEvent<HTMLModusIconElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLModusIconElement: {
        prototype: HTMLModusIconElement;
        new (): HTMLModusIconElement;
    };
    interface HTMLModusListElement extends Components.ModusList, HTMLStencilElement {
    }
    var HTMLModusListElement: {
        prototype: HTMLModusListElement;
        new (): HTMLModusListElement;
    };
    interface HTMLModusListItemElementEventMap {
        "itemClick": any;
    }
    interface HTMLModusListItemElement extends Components.ModusListItem, HTMLStencilElement {
        addEventListener<K extends keyof HTMLModusListItemElementEventMap>(type: K, listener: (this: HTMLModusListItemElement, ev: ModusListItemCustomEvent<HTMLModusListItemElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLModusListItemElementEventMap>(type: K, listener: (this: HTMLModusListItemElement, ev: ModusListItemCustomEvent<HTMLModusListItemElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLModusListItemElement: {
        prototype: HTMLModusListItemElement;
        new (): HTMLModusListItemElement;
    };
    interface HTMLModusMessageElement extends Components.ModusMessage, HTMLStencilElement {
    }
    var HTMLModusMessageElement: {
        prototype: HTMLModusMessageElement;
        new (): HTMLModusMessageElement;
    };
    interface HTMLModusModalElementEventMap {
        "closed": any;
        "opened": any;
        "primaryButtonClick": any;
        "secondaryButtonClick": any;
    }
    interface HTMLModusModalElement extends Components.ModusModal, HTMLStencilElement {
        addEventListener<K extends keyof HTMLModusModalElementEventMap>(type: K, listener: (this: HTMLModusModalElement, ev: ModusModalCustomEvent<HTMLModusModalElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLModusModalElementEventMap>(type: K, listener: (this: HTMLModusModalElement, ev: ModusModalCustomEvent<HTMLModusModalElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLModusModalElement: {
        prototype: HTMLModusModalElement;
        new (): HTMLModusModalElement;
    };
    interface HTMLModusNavbarElementEventMap {
        "appsMenuOpen": void;
        "appsMenuAppOpen": ModusNavbarApp;
        "buttonClick": string;
        "helpOpen": void;
        "mainMenuClick": KeyboardEvent | MouseEvent;
        "notificationsMenuOpen": void;
        "productLogoClick": MouseEvent;
        "profileMenuLinkClick": string;
        "profileMenuOpen": void;
        "profileMenuSignOutClick": KeyboardEvent | MouseEvent;
        "searchChange": string;
        "searchMenuClick": void;
    }
    interface HTMLModusNavbarElement extends Components.ModusNavbar, HTMLStencilElement {
        addEventListener<K extends keyof HTMLModusNavbarElementEventMap>(type: K, listener: (this: HTMLModusNavbarElement, ev: ModusNavbarCustomEvent<HTMLModusNavbarElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLModusNavbarElementEventMap>(type: K, listener: (this: HTMLModusNavbarElement, ev: ModusNavbarCustomEvent<HTMLModusNavbarElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLModusNavbarElement: {
        prototype: HTMLModusNavbarElement;
        new (): HTMLModusNavbarElement;
    };
    interface HTMLModusNavbarAppsMenuElementEventMap {
        "appOpen": ModusNavbarApp1;
    }
    interface HTMLModusNavbarAppsMenuElement extends Components.ModusNavbarAppsMenu, HTMLStencilElement {
        addEventListener<K extends keyof HTMLModusNavbarAppsMenuElementEventMap>(type: K, listener: (this: HTMLModusNavbarAppsMenuElement, ev: ModusNavbarAppsMenuCustomEvent<HTMLModusNavbarAppsMenuElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLModusNavbarAppsMenuElementEventMap>(type: K, listener: (this: HTMLModusNavbarAppsMenuElement, ev: ModusNavbarAppsMenuCustomEvent<HTMLModusNavbarAppsMenuElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLModusNavbarAppsMenuElement: {
        prototype: HTMLModusNavbarAppsMenuElement;
        new (): HTMLModusNavbarAppsMenuElement;
    };
    interface HTMLModusNavbarButtonMenuElement extends Components.ModusNavbarButtonMenu, HTMLStencilElement {
    }
    var HTMLModusNavbarButtonMenuElement: {
        prototype: HTMLModusNavbarButtonMenuElement;
        new (): HTMLModusNavbarButtonMenuElement;
    };
    interface HTMLModusNavbarMainMenuElement extends Components.ModusNavbarMainMenu, HTMLStencilElement {
    }
    var HTMLModusNavbarMainMenuElement: {
        prototype: HTMLModusNavbarMainMenuElement;
        new (): HTMLModusNavbarMainMenuElement;
    };
    interface HTMLModusNavbarNotificationsMenuElement extends Components.ModusNavbarNotificationsMenu, HTMLStencilElement {
    }
    var HTMLModusNavbarNotificationsMenuElement: {
        prototype: HTMLModusNavbarNotificationsMenuElement;
        new (): HTMLModusNavbarNotificationsMenuElement;
    };
    interface HTMLModusNavbarProfileMenuElementEventMap {
        "linkClick": string;
        "signOutClick": MouseEvent;
    }
    interface HTMLModusNavbarProfileMenuElement extends Components.ModusNavbarProfileMenu, HTMLStencilElement {
        addEventListener<K extends keyof HTMLModusNavbarProfileMenuElementEventMap>(type: K, listener: (this: HTMLModusNavbarProfileMenuElement, ev: ModusNavbarProfileMenuCustomEvent<HTMLModusNavbarProfileMenuElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLModusNavbarProfileMenuElementEventMap>(type: K, listener: (this: HTMLModusNavbarProfileMenuElement, ev: ModusNavbarProfileMenuCustomEvent<HTMLModusNavbarProfileMenuElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLModusNavbarProfileMenuElement: {
        prototype: HTMLModusNavbarProfileMenuElement;
        new (): HTMLModusNavbarProfileMenuElement;
    };
    interface HTMLModusNavbarSearchOverlayElementEventMap {
        "close": void;
        "search": string;
    }
    interface HTMLModusNavbarSearchOverlayElement extends Components.ModusNavbarSearchOverlay, HTMLStencilElement {
        addEventListener<K extends keyof HTMLModusNavbarSearchOverlayElementEventMap>(type: K, listener: (this: HTMLModusNavbarSearchOverlayElement, ev: ModusNavbarSearchOverlayCustomEvent<HTMLModusNavbarSearchOverlayElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLModusNavbarSearchOverlayElementEventMap>(type: K, listener: (this: HTMLModusNavbarSearchOverlayElement, ev: ModusNavbarSearchOverlayCustomEvent<HTMLModusNavbarSearchOverlayElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLModusNavbarSearchOverlayElement: {
        prototype: HTMLModusNavbarSearchOverlayElement;
        new (): HTMLModusNavbarSearchOverlayElement;
    };
    interface HTMLModusNumberInputElementEventMap {
        "valueChange": string;
    }
    interface HTMLModusNumberInputElement extends Components.ModusNumberInput, HTMLStencilElement {
        addEventListener<K extends keyof HTMLModusNumberInputElementEventMap>(type: K, listener: (this: HTMLModusNumberInputElement, ev: ModusNumberInputCustomEvent<HTMLModusNumberInputElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLModusNumberInputElementEventMap>(type: K, listener: (this: HTMLModusNumberInputElement, ev: ModusNumberInputCustomEvent<HTMLModusNumberInputElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLModusNumberInputElement: {
        prototype: HTMLModusNumberInputElement;
        new (): HTMLModusNumberInputElement;
    };
    interface HTMLModusPaginationElementEventMap {
        "pageChange": number;
    }
    interface HTMLModusPaginationElement extends Components.ModusPagination, HTMLStencilElement {
        addEventListener<K extends keyof HTMLModusPaginationElementEventMap>(type: K, listener: (this: HTMLModusPaginationElement, ev: ModusPaginationCustomEvent<HTMLModusPaginationElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLModusPaginationElementEventMap>(type: K, listener: (this: HTMLModusPaginationElement, ev: ModusPaginationCustomEvent<HTMLModusPaginationElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLModusPaginationElement: {
        prototype: HTMLModusPaginationElement;
        new (): HTMLModusPaginationElement;
    };
    interface HTMLModusProgressBarElement extends Components.ModusProgressBar, HTMLStencilElement {
    }
    var HTMLModusProgressBarElement: {
        prototype: HTMLModusProgressBarElement;
        new (): HTMLModusProgressBarElement;
    };
    interface HTMLModusRadioGroupElementEventMap {
        "buttonClick": string;
    }
    interface HTMLModusRadioGroupElement extends Components.ModusRadioGroup, HTMLStencilElement {
        addEventListener<K extends keyof HTMLModusRadioGroupElementEventMap>(type: K, listener: (this: HTMLModusRadioGroupElement, ev: ModusRadioGroupCustomEvent<HTMLModusRadioGroupElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLModusRadioGroupElementEventMap>(type: K, listener: (this: HTMLModusRadioGroupElement, ev: ModusRadioGroupCustomEvent<HTMLModusRadioGroupElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLModusRadioGroupElement: {
        prototype: HTMLModusRadioGroupElement;
        new (): HTMLModusRadioGroupElement;
    };
    interface HTMLModusSelectElementEventMap {
        "valueChange": unknown;
        "inputBlur": FocusEvent;
    }
    interface HTMLModusSelectElement extends Components.ModusSelect, HTMLStencilElement {
        addEventListener<K extends keyof HTMLModusSelectElementEventMap>(type: K, listener: (this: HTMLModusSelectElement, ev: ModusSelectCustomEvent<HTMLModusSelectElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLModusSelectElementEventMap>(type: K, listener: (this: HTMLModusSelectElement, ev: ModusSelectCustomEvent<HTMLModusSelectElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLModusSelectElement: {
        prototype: HTMLModusSelectElement;
        new (): HTMLModusSelectElement;
    };
    interface HTMLModusSentimentScaleElementEventMap {
        "sentimentSelection": any;
    }
    interface HTMLModusSentimentScaleElement extends Components.ModusSentimentScale, HTMLStencilElement {
        addEventListener<K extends keyof HTMLModusSentimentScaleElementEventMap>(type: K, listener: (this: HTMLModusSentimentScaleElement, ev: ModusSentimentScaleCustomEvent<HTMLModusSentimentScaleElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLModusSentimentScaleElementEventMap>(type: K, listener: (this: HTMLModusSentimentScaleElement, ev: ModusSentimentScaleCustomEvent<HTMLModusSentimentScaleElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLModusSentimentScaleElement: {
        prototype: HTMLModusSentimentScaleElement;
        new (): HTMLModusSentimentScaleElement;
    };
    interface HTMLModusSideNavigationElementEventMap {
        "sideNavExpand": boolean;
    }
    interface HTMLModusSideNavigationElement extends Components.ModusSideNavigation, HTMLStencilElement {
        addEventListener<K extends keyof HTMLModusSideNavigationElementEventMap>(type: K, listener: (this: HTMLModusSideNavigationElement, ev: ModusSideNavigationCustomEvent<HTMLModusSideNavigationElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLModusSideNavigationElementEventMap>(type: K, listener: (this: HTMLModusSideNavigationElement, ev: ModusSideNavigationCustomEvent<HTMLModusSideNavigationElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLModusSideNavigationElement: {
        prototype: HTMLModusSideNavigationElement;
        new (): HTMLModusSideNavigationElement;
    };
    interface HTMLModusSideNavigationItemElementEventMap {
        "sideNavItemClicked": { id: string; selected: boolean };
        "sideNavItemFocus": { id: string };
        "_sideNavItemAdded": HTMLElement;
        "_sideNavItemRemoved": HTMLElement;
    }
    interface HTMLModusSideNavigationItemElement extends Components.ModusSideNavigationItem, HTMLStencilElement {
        addEventListener<K extends keyof HTMLModusSideNavigationItemElementEventMap>(type: K, listener: (this: HTMLModusSideNavigationItemElement, ev: ModusSideNavigationItemCustomEvent<HTMLModusSideNavigationItemElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLModusSideNavigationItemElementEventMap>(type: K, listener: (this: HTMLModusSideNavigationItemElement, ev: ModusSideNavigationItemCustomEvent<HTMLModusSideNavigationItemElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLModusSideNavigationItemElement: {
        prototype: HTMLModusSideNavigationItemElement;
        new (): HTMLModusSideNavigationItemElement;
    };
    interface HTMLModusSliderElementEventMap {
        "valueChange": string;
        "valueInput": string;
    }
    interface HTMLModusSliderElement extends Components.ModusSlider, HTMLStencilElement {
        addEventListener<K extends keyof HTMLModusSliderElementEventMap>(type: K, listener: (this: HTMLModusSliderElement, ev: ModusSliderCustomEvent<HTMLModusSliderElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLModusSliderElementEventMap>(type: K, listener: (this: HTMLModusSliderElement, ev: ModusSliderCustomEvent<HTMLModusSliderElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLModusSliderElement: {
        prototype: HTMLModusSliderElement;
        new (): HTMLModusSliderElement;
    };
    interface HTMLModusSpinnerElement extends Components.ModusSpinner, HTMLStencilElement {
    }
    var HTMLModusSpinnerElement: {
        prototype: HTMLModusSpinnerElement;
        new (): HTMLModusSpinnerElement;
    };
    interface HTMLModusSwitchElementEventMap {
        "switchClick": boolean;
    }
    interface HTMLModusSwitchElement extends Components.ModusSwitch, HTMLStencilElement {
        addEventListener<K extends keyof HTMLModusSwitchElementEventMap>(type: K, listener: (this: HTMLModusSwitchElement, ev: ModusSwitchCustomEvent<HTMLModusSwitchElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLModusSwitchElementEventMap>(type: K, listener: (this: HTMLModusSwitchElement, ev: ModusSwitchCustomEvent<HTMLModusSwitchElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLModusSwitchElement: {
        prototype: HTMLModusSwitchElement;
        new (): HTMLModusSwitchElement;
    };
    interface HTMLModusTableElementEventMap {
        "cellValueChange": ModusTableCellValueChange;
        "cellLinkClick": ModusTableCellLink;
        "columnOrderChange": ModusTableColumnOrderState;
        "columnSizingChange": ModusTableColumnSizingState;
        "columnVisibilityChange": ModusTableColumnVisibilityState;
        "rowActionClick": ModusTableRowActionClick;
        "rowExpanded": ModusTableExpandedState;
        "rowSelectionChange": unknown;
        "sortChange": ModusTableSortingState;
        "paginationChange": ModusTablePaginationState;
    }
    interface HTMLModusTableElement extends Components.ModusTable, HTMLStencilElement {
        addEventListener<K extends keyof HTMLModusTableElementEventMap>(type: K, listener: (this: HTMLModusTableElement, ev: ModusTableCustomEvent<HTMLModusTableElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLModusTableElementEventMap>(type: K, listener: (this: HTMLModusTableElement, ev: ModusTableCustomEvent<HTMLModusTableElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLModusTableElement: {
        prototype: HTMLModusTableElement;
        new (): HTMLModusTableElement;
    };
    interface HTMLModusTableCellEditorElement extends Components.ModusTableCellEditor, HTMLStencilElement {
    }
    var HTMLModusTableCellEditorElement: {
        prototype: HTMLModusTableCellEditorElement;
        new (): HTMLModusTableCellEditorElement;
    };
    interface HTMLModusTableCellMainElement extends Components.ModusTableCellMain, HTMLStencilElement {
    }
    var HTMLModusTableCellMainElement: {
        prototype: HTMLModusTableCellMainElement;
        new (): HTMLModusTableCellMainElement;
    };
    interface HTMLModusTableColumnsVisibilityElement extends Components.ModusTableColumnsVisibility, HTMLStencilElement {
    }
    var HTMLModusTableColumnsVisibilityElement: {
        prototype: HTMLModusTableColumnsVisibilityElement;
        new (): HTMLModusTableColumnsVisibilityElement;
    };
    interface HTMLModusTableDropdownMenuElement extends Components.ModusTableDropdownMenu, HTMLStencilElement {
    }
    var HTMLModusTableDropdownMenuElement: {
        prototype: HTMLModusTableDropdownMenuElement;
        new (): HTMLModusTableDropdownMenuElement;
    };
    /**
     * ModusFillerColumn is to fill empty space within a table or grid when the content in other columns is not wide enough to occupy the entire available width
     */
    interface HTMLModusTableFillerColumnElement extends Components.ModusTableFillerColumn, HTMLStencilElement {
    }
    var HTMLModusTableFillerColumnElement: {
        prototype: HTMLModusTableFillerColumnElement;
        new (): HTMLModusTableFillerColumnElement;
    };
    interface HTMLModusTableRowActionsElementEventMap {
        "overflowRowActions": any;
    }
    interface HTMLModusTableRowActionsElement extends Components.ModusTableRowActions, HTMLStencilElement {
        addEventListener<K extends keyof HTMLModusTableRowActionsElementEventMap>(type: K, listener: (this: HTMLModusTableRowActionsElement, ev: ModusTableRowActionsCustomEvent<HTMLModusTableRowActionsElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLModusTableRowActionsElementEventMap>(type: K, listener: (this: HTMLModusTableRowActionsElement, ev: ModusTableRowActionsCustomEvent<HTMLModusTableRowActionsElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLModusTableRowActionsElement: {
        prototype: HTMLModusTableRowActionsElement;
        new (): HTMLModusTableRowActionsElement;
    };
    interface HTMLModusTableRowActionsCellElement extends Components.ModusTableRowActionsCell, HTMLStencilElement {
    }
    var HTMLModusTableRowActionsCellElement: {
        prototype: HTMLModusTableRowActionsCellElement;
        new (): HTMLModusTableRowActionsCellElement;
    };
    interface HTMLModusTableRowActionsMenuElement extends Components.ModusTableRowActionsMenu, HTMLStencilElement {
    }
    var HTMLModusTableRowActionsMenuElement: {
        prototype: HTMLModusTableRowActionsMenuElement;
        new (): HTMLModusTableRowActionsMenuElement;
    };
    interface HTMLModusTableToolbarElement extends Components.ModusTableToolbar, HTMLStencilElement {
    }
    var HTMLModusTableToolbarElement: {
        prototype: HTMLModusTableToolbarElement;
        new (): HTMLModusTableToolbarElement;
    };
    interface HTMLModusTabsElementEventMap {
        "tabChange": string;
    }
    interface HTMLModusTabsElement extends Components.ModusTabs, HTMLStencilElement {
        addEventListener<K extends keyof HTMLModusTabsElementEventMap>(type: K, listener: (this: HTMLModusTabsElement, ev: ModusTabsCustomEvent<HTMLModusTabsElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLModusTabsElementEventMap>(type: K, listener: (this: HTMLModusTabsElement, ev: ModusTabsCustomEvent<HTMLModusTabsElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLModusTabsElement: {
        prototype: HTMLModusTabsElement;
        new (): HTMLModusTabsElement;
    };
    interface HTMLModusTextInputElementEventMap {
        "valueChange": string;
    }
    interface HTMLModusTextInputElement extends Components.ModusTextInput, HTMLStencilElement {
        addEventListener<K extends keyof HTMLModusTextInputElementEventMap>(type: K, listener: (this: HTMLModusTextInputElement, ev: ModusTextInputCustomEvent<HTMLModusTextInputElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLModusTextInputElementEventMap>(type: K, listener: (this: HTMLModusTextInputElement, ev: ModusTextInputCustomEvent<HTMLModusTextInputElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLModusTextInputElement: {
        prototype: HTMLModusTextInputElement;
        new (): HTMLModusTextInputElement;
    };
    interface HTMLModusTimePickerElementEventMap {
        "timeInputBlur": ModusTimePickerEventDetails;
        "valueChange": ModusTimePickerEventDetails;
    }
    interface HTMLModusTimePickerElement extends Components.ModusTimePicker, HTMLStencilElement {
        addEventListener<K extends keyof HTMLModusTimePickerElementEventMap>(type: K, listener: (this: HTMLModusTimePickerElement, ev: ModusTimePickerCustomEvent<HTMLModusTimePickerElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLModusTimePickerElementEventMap>(type: K, listener: (this: HTMLModusTimePickerElement, ev: ModusTimePickerCustomEvent<HTMLModusTimePickerElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLModusTimePickerElement: {
        prototype: HTMLModusTimePickerElement;
        new (): HTMLModusTimePickerElement;
    };
    interface HTMLModusToastElementEventMap {
        "dismissClick": any;
    }
    interface HTMLModusToastElement extends Components.ModusToast, HTMLStencilElement {
        addEventListener<K extends keyof HTMLModusToastElementEventMap>(type: K, listener: (this: HTMLModusToastElement, ev: ModusToastCustomEvent<HTMLModusToastElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLModusToastElementEventMap>(type: K, listener: (this: HTMLModusToastElement, ev: ModusToastCustomEvent<HTMLModusToastElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLModusToastElement: {
        prototype: HTMLModusToastElement;
        new (): HTMLModusToastElement;
    };
    interface HTMLModusTooltipElement extends Components.ModusTooltip, HTMLStencilElement {
    }
    var HTMLModusTooltipElement: {
        prototype: HTMLModusTooltipElement;
        new (): HTMLModusTooltipElement;
    };
    interface HTMLModusTreeViewElementEventMap {
        "itemActionClick": any;
    }
    interface HTMLModusTreeViewElement extends Components.ModusTreeView, HTMLStencilElement {
        addEventListener<K extends keyof HTMLModusTreeViewElementEventMap>(type: K, listener: (this: HTMLModusTreeViewElement, ev: ModusTreeViewCustomEvent<HTMLModusTreeViewElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLModusTreeViewElementEventMap>(type: K, listener: (this: HTMLModusTreeViewElement, ev: ModusTreeViewCustomEvent<HTMLModusTreeViewElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLModusTreeViewElement: {
        prototype: HTMLModusTreeViewElement;
        new (): HTMLModusTreeViewElement;
    };
    interface HTMLModusTreeViewItemElementEventMap {
        "checkboxClick": boolean;
        "itemClick": boolean;
        "itemExpandToggle": boolean;
        "itemAdded": HTMLElement;
        "actionClick": any;
    }
    interface HTMLModusTreeViewItemElement extends Components.ModusTreeViewItem, HTMLStencilElement {
        addEventListener<K extends keyof HTMLModusTreeViewItemElementEventMap>(type: K, listener: (this: HTMLModusTreeViewItemElement, ev: ModusTreeViewItemCustomEvent<HTMLModusTreeViewItemElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLModusTreeViewItemElementEventMap>(type: K, listener: (this: HTMLModusTreeViewItemElement, ev: ModusTreeViewItemCustomEvent<HTMLModusTreeViewItemElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLModusTreeViewItemElement: {
        prototype: HTMLModusTreeViewItemElement;
        new (): HTMLModusTreeViewItemElement;
    };
    interface HTMLElementTagNameMap {
        "modus-accordion": HTMLModusAccordionElement;
        "modus-accordion-item": HTMLModusAccordionItemElement;
        "modus-action-bar": HTMLModusActionBarElement;
        "modus-alert": HTMLModusAlertElement;
        "modus-autocomplete": HTMLModusAutocompleteElement;
        "modus-badge": HTMLModusBadgeElement;
        "modus-breadcrumb": HTMLModusBreadcrumbElement;
        "modus-button": HTMLModusButtonElement;
        "modus-card": HTMLModusCardElement;
        "modus-checkbox": HTMLModusCheckboxElement;
        "modus-chip": HTMLModusChipElement;
        "modus-data-table": HTMLModusDataTableElement;
        "modus-date-input": HTMLModusDateInputElement;
        "modus-date-picker": HTMLModusDatePickerElement;
        "modus-dropdown": HTMLModusDropdownElement;
        "modus-file-dropzone": HTMLModusFileDropzoneElement;
        "modus-icon": HTMLModusIconElement;
        "modus-list": HTMLModusListElement;
        "modus-list-item": HTMLModusListItemElement;
        "modus-message": HTMLModusMessageElement;
        "modus-modal": HTMLModusModalElement;
        "modus-navbar": HTMLModusNavbarElement;
        "modus-navbar-apps-menu": HTMLModusNavbarAppsMenuElement;
        "modus-navbar-button-menu": HTMLModusNavbarButtonMenuElement;
        "modus-navbar-main-menu": HTMLModusNavbarMainMenuElement;
        "modus-navbar-notifications-menu": HTMLModusNavbarNotificationsMenuElement;
        "modus-navbar-profile-menu": HTMLModusNavbarProfileMenuElement;
        "modus-navbar-search-overlay": HTMLModusNavbarSearchOverlayElement;
        "modus-number-input": HTMLModusNumberInputElement;
        "modus-pagination": HTMLModusPaginationElement;
        "modus-progress-bar": HTMLModusProgressBarElement;
        "modus-radio-group": HTMLModusRadioGroupElement;
        "modus-select": HTMLModusSelectElement;
        "modus-sentiment-scale": HTMLModusSentimentScaleElement;
        "modus-side-navigation": HTMLModusSideNavigationElement;
        "modus-side-navigation-item": HTMLModusSideNavigationItemElement;
        "modus-slider": HTMLModusSliderElement;
        "modus-spinner": HTMLModusSpinnerElement;
        "modus-switch": HTMLModusSwitchElement;
        "modus-table": HTMLModusTableElement;
        "modus-table-cell-editor": HTMLModusTableCellEditorElement;
        "modus-table-cell-main": HTMLModusTableCellMainElement;
        "modus-table-columns-visibility": HTMLModusTableColumnsVisibilityElement;
        "modus-table-dropdown-menu": HTMLModusTableDropdownMenuElement;
        "modus-table-filler-column": HTMLModusTableFillerColumnElement;
        "modus-table-row-actions": HTMLModusTableRowActionsElement;
        "modus-table-row-actions-cell": HTMLModusTableRowActionsCellElement;
        "modus-table-row-actions-menu": HTMLModusTableRowActionsMenuElement;
        "modus-table-toolbar": HTMLModusTableToolbarElement;
        "modus-tabs": HTMLModusTabsElement;
        "modus-text-input": HTMLModusTextInputElement;
        "modus-time-picker": HTMLModusTimePickerElement;
        "modus-toast": HTMLModusToastElement;
        "modus-tooltip": HTMLModusTooltipElement;
        "modus-tree-view": HTMLModusTreeViewElement;
        "modus-tree-view-item": HTMLModusTreeViewItemElement;
    }
}
declare namespace LocalJSX {
    interface ModusAccordion {
        /**
          * (optional) The accordion's aria-label.
         */
        "ariaLabel"?: string | null;
    }
    interface ModusAccordionItem {
        /**
          * (optional) Disables the accordion item, locks expand/collapse.
         */
        "disabled"?: boolean;
        /**
          * (optional) The type of expand button
         */
        "expandButtonType"?: 'standardArrow' | 'circleArrow';
        /**
          * (optional) Whether the accordion item is expanded.
         */
        "expanded"?: boolean;
        /**
          * (required) The text to render in the header.
         */
        "headerText"?: string;
        /**
          * (optional) The icon to display before the header text.
         */
        "icon"?: string;
        /**
          * An event that fires on every accordion close.
         */
        "onClosed"?: (event: ModusAccordionItemCustomEvent<any>) => void;
        /**
          * An event that fires on every accordion open.
         */
        "onOpened"?: (event: ModusAccordionItemCustomEvent<any>) => void;
        /**
          * (optional) The size of accordion item.
         */
        "size"?: 'condensed' | 'standard';
    }
    interface ModusActionBar {
        /**
          * (optional) List of actions
         */
        "actions"?: ModusActionBarOptions[];
        /**
          * (optional) An event that fires on action item click.
         */
        "onActionBarClick"?: (event: ModusActionBarCustomEvent<any>) => void;
        /**
          * (optional) The size of the action items.
         */
        "size"?: 'small' | 'medium' | 'large';
        /**
          * (optional) Total number of icons to show
         */
        "visibleItemCount"?: number;
    }
    interface ModusAlert {
        /**
          * (optional) The alert's aria-label.
         */
        "ariaLabel"?: string | null;
        /**
          * (optional) The button's aria-label.
         */
        "buttonAriaLabel"?: string | null;
        /**
          * (optional) The button's text
         */
        "buttonText"?: string | null;
        /**
          * (optional) Whether the alert has a dismiss button
         */
        "dismissible"?: boolean;
        /**
          * (optional) The alert message
         */
        "message"?: string;
        /**
          * An event that firest when the action button is clicked
         */
        "onActionClick"?: (event: ModusAlertCustomEvent<any>) => void;
        /**
          * An event that fires when the alert is dismissed
         */
        "onDismissClick"?: (event: ModusAlertCustomEvent<any>) => void;
        /**
          * (optional) The type of alert, sets the color and icon to render
         */
        "type"?: 'error' | 'info' | 'info-gray' | 'info-gray-dark' | 'success' | 'warning';
    }
    interface ModusAutocomplete {
        /**
          * The autocomplete's aria label.
         */
        "ariaLabel"?: string | null;
        /**
          * Whether the input has a clear button.
         */
        "clearable"?: boolean;
        /**
          * Whether the autocomplete's options always display on select.
         */
        "disableCloseOnSelect"?: boolean;
        /**
          * Whether the input is disabled.
         */
        "disabled"?: boolean;
        /**
          * The autocomplete's dropdown's max height.
         */
        "dropdownMaxHeight"?: string;
        /**
          * The autocomplete's dropdown z-index.
         */
        "dropdownZIndex"?: string;
        /**
          * The autocomplete's error text.
         */
        "errorText"?: string;
        /**
          * Whether the search icon is included.
         */
        "includeSearchIcon"?: boolean;
        /**
          * The autocomplete's label.
         */
        "label"?: string;
        /**
          * When enabled, multiple options can be selected in the component. And selected options are shown as chips in the input.
         */
        "multiple"?: boolean;
        /**
          * The autocomplete's no results sub-text.
         */
        "noResultsFoundSubtext"?: string;
        /**
          * The autocomplete's no results text.
         */
        "noResultsFoundText"?: string;
        /**
          * An event that fires when a dropdown option is selected. Emits the option id.
         */
        "onOptionSelected"?: (event: ModusAutocompleteCustomEvent<string>) => void;
        /**
          * An event that fires when the input value changes. Emits the value string.
         */
        "onValueChange"?: (event: ModusAutocompleteCustomEvent<string>) => void;
        /**
          * The autocomplete's options.
         */
        "options"?: ModusAutocompleteOption[] | string[];
        /**
          * The autocomplete's input placeholder.
         */
        "placeholder"?: string;
        /**
          * Whether the autocomplete is read-only.
         */
        "readOnly"?: boolean;
        /**
          * Whether the autocomplete is required.
         */
        "required"?: boolean;
        /**
          * Whether to show the no results found message.
         */
        "showNoResultsFoundMessage"?: boolean;
        /**
          * Whether to show autocomplete's options when focus.
         */
        "showOptionsOnFocus"?: boolean;
        /**
          * The autocomplete's size.
         */
        "size"?: 'medium' | 'large';
        /**
          * The autocomplete's search value.
         */
        "value"?: string;
    }
    interface ModusBadge {
        /**
          * (optional) The badge's aria-label
         */
        "ariaLabel"?: BadgeProperties['ariaLabel'];
        /**
          * (optional) The color of the badge
         */
        "color"?: BadgeProperties['color'];
        /**
          * (optional) The size of the badge
         */
        "size"?: BadgeProperties['size'];
        /**
          * (optional) The type of the badge
         */
        "type"?: BadgeProperties['type'];
    }
    interface ModusBreadcrumb {
        /**
          * The breadcrumb's aria-label.
         */
        "ariaLabel"?: string | null;
        /**
          * The breadcrumbs to render.
         */
        "crumbs"?: Crumb[];
        /**
          * (optional) An event that fires on breadcrumb click.
         */
        "onCrumbClick"?: (event: ModusBreadcrumbCustomEvent<Crumb>) => void;
        /**
          * (optional) A flag that controls the display of underline
         */
        "underlineLinks"?: boolean;
    }
    interface ModusButton {
        /**
          * (optional) The button's aria-disabled state.
         */
        "ariaDisabled"?: string | null;
        /**
          * (optional) The button's aria-label.
         */
        "ariaLabel"?: string | null;
        /**
          * (optional) The style of the button
         */
        "buttonStyle"?: 'borderless' | 'fill' | 'outline';
        /**
          * (optional) The color of the button
         */
        "color"?: 'danger' | 'primary' | 'secondary' | 'tertiary';
        /**
          * (optional) Disables the button.
         */
        "disabled"?: boolean;
        /**
          * (optional) Takes the icon name and renders an icon-only button.
         */
        "iconOnly"?: string;
        /**
          * (optional) Takes the icon name and shows the icon aligned to the left of the button text.
         */
        "leftIcon"?: string;
        /**
          * (optional) An event that fires on button click.
         */
        "onButtonClick"?: (event: ModusButtonCustomEvent<any>) => void;
        /**
          * (optional) Takes the icon name and shows the icon aligned to the right of the button text.
         */
        "rightIcon"?: string;
        /**
          * (optional) Shows a caret icon right side of the button.
         */
        "showCaret"?: boolean;
        /**
          * (optional) The size of the button.
         */
        "size"?: 'small' | 'medium' | 'large';
        /**
          * (Optional) Button types
         */
        "type"?: 'button' | 'reset' | 'submit';
    }
    interface ModusCard {
        /**
          * (optional) The card's aria-label.
         */
        "ariaLabel"?: string | null;
        /**
          * (optional) The border radius of the card.
         */
        "borderRadius"?: string;
        /**
          * (optional) The height of the card.
         */
        "height"?: string;
        /**
          * (optional) A flag that controls the display of border.
         */
        "showCardBorder"?: boolean;
        /**
          * (optional) A flag that controls the display of shadow box when the element is hovered.
         */
        "showShadowOnHover"?: boolean;
        /**
          * (optional) The width of the card.
         */
        "width"?: string;
    }
    interface ModusCheckbox {
        /**
          * (optional) The checkbox's aria-label.
         */
        "ariaLabel"?: string | null;
        /**
          * (optional) Whether the checkbox is checked.
         */
        "checked"?: boolean;
        /**
          * (optional) Whether the checkbox is disabled.
         */
        "disabled"?: boolean;
        /**
          * (optional) Whether the checkbox is indeterminate.
         */
        "indeterminate"?: boolean;
        /**
          * (optional) The checkbox label.
         */
        "label"?: string;
        /**
          * An event that fires on checkbox click.
         */
        "onCheckboxClick"?: (event: ModusCheckboxCustomEvent<boolean>) => void;
        /**
          * (optional) The size of the checkbox.
         */
        "size"?: 'small' | 'medium';
        /**
          * (optional) If you wish to prevent the propagation of your event, you may opt for this.
         */
        "stopPropagation"?: boolean;
        /**
          * (optional) Tab Index for the checkbox
         */
        "tabIndexValue"?: string | number;
    }
    interface ModusChip {
        /**
          * (optional) The chip's aria-label.
         */
        "ariaLabel"?: string | null;
        /**
          * (optional) The chip's style.
         */
        "chipStyle"?: 'outline' | 'solid';
        /**
          * (optional) Whether the chip is disabled.
         */
        "disabled"?: boolean;
        /**
          * (optional) Whether the chip has an error.
         */
        "hasError"?: boolean;
        /**
          * (optional) The image's url.
         */
        "imageUrl"?: string;
        /**
          * (optional) Maximum width for the Chip's text and shows ellipsis when truncated
         */
        "maxWidth"?: string;
        /**
          * An event that fires on chip click.
         */
        "onChipClick"?: (event: ModusChipCustomEvent<any>) => void;
        /**
          * An event that fires on close icon click.
         */
        "onCloseClick"?: (event: ModusChipCustomEvent<any>) => void;
        /**
          * (optional) Whether to show the checkmark.
         */
        "showCheckmark"?: boolean;
        /**
          * (optional) Whether to show the close icon.
         */
        "showClose"?: boolean;
        /**
          * (optional) The chip's size.
         */
        "size"?: 'medium' | 'small';
        /**
          * (optional) The chip's value.
         */
        "value"?: string;
    }
    interface ModusDataTable {
        "columns": string[] | TColumn[];
        "data": TCell[][] | TRow[];
        /**
          * Options for data table display.
         */
        "displayOptions"?: ModusDataTableDisplayOptions;
        /**
          * An event that fires on cell link click.
         */
        "onCellLinkClick"?: (event: ModusDataTableCustomEvent<ModusDataTableCellLink>) => void;
        /**
          * An event that fires when a row action is clicked.
         */
        "onRowActionClick"?: (event: ModusDataTableCustomEvent<ModusDataTableRowActionClickEvent>) => void;
        /**
          * An event that fires on row double click.
         */
        "onRowDoubleClick"?: (event: ModusDataTableCustomEvent<string>) => void;
        /**
          * An event that fires on selection change.
         */
        "onSelection"?: (event: ModusDataTableCustomEvent<string[]>) => void;
        /**
          * An event that fires on column sort.
         */
        "onSort"?: (event: ModusDataTableCustomEvent<ModusDataTableSortEvent>) => void;
        /**
          * Actions that can be performed on each row.
         */
        "rowActions"?: ModusDataTableRowAction[];
        /**
          * Options for data table item selection.
         */
        "selectionOptions"?: ModusDataTableSelectionOptions;
        /**
          * Options for data table column sort.
         */
        "sortOptions"?: ModusDataTableSortOptions;
    }
    interface ModusDateInput {
        /**
          * (optional) Regular expression to allow characters while typing the input.
         */
        "allowedCharsRegex"?: RegExp | string;
        /**
          * Alternative formats string for the date input split by | separator. Use 'm','mm' for month, 'd','dd' for date and 'yy','yyyy' for year with any separator that is not a regular expression.
         */
        "altFormats"?: string;
        /**
          * (optional) The input's aria-label.
         */
        "ariaLabel"?: string | null;
        /**
          * (optional) Sets autofocus on the input.
         */
        "autoFocusInput"?: boolean;
        /**
          * (optional) Disables default validation for the date input.
         */
        "disableValidation"?: boolean;
        /**
          * (optional) Whether the input is disabled.
         */
        "disabled"?: boolean;
        /**
          * (optional) Custom error text displayed for the input.
         */
        "errorText"?: string;
        /**
          * (optional) Filler date is used as fillers for parts not in the display format when constructing a full date string, for 'value'. It must be in the ISO String format YYYY-MM-DD. Default is {current year}-01-01.
         */
        "fillerDate"?: string;
        /**
          * Format string for the date input. Default 'mm/dd/yyyy'. Use 'm','mm' for month, 'd','dd' for date and 'yy','yyyy' for year with any separator that is not a regular expression.
         */
        "format"?: string;
        /**
          * (optional) Custom helper text displayed below the input.
         */
        "helperText"?: string;
        /**
          * (optional) The input's label.
         */
        "label"?: string;
        /**
          * (optional) The maximum date allowed. The date is formatted according to ISO8601 'yyyy-mm-dd'.
         */
        "max"?: string;
        /**
          * (optional) The minimum date allowed. The date is formatted according to ISO8601 'yyyy-mm-dd'.
         */
        "min"?: string;
        /**
          * An event that fires on calendar icon click.
         */
        "onCalendarIconClicked"?: (event: ModusDateInputCustomEvent<ModusDateInputEventDetails>) => void;
        /**
          * An event that fires on input value out of focus.
         */
        "onDateInputBlur"?: (event: ModusDateInputCustomEvent<ModusDateInputEventDetails>) => void;
        /**
          * An event that fires on input value change.
         */
        "onValueChange"?: (event: ModusDateInputCustomEvent<ModusDateInputEventDetails>) => void;
        /**
          * (optional) The input's placeholder text.
         */
        "placeholder"?: string;
        /**
          * (optional) Whether the input's content is read-only
         */
        "readOnly"?: boolean;
        /**
          * (optional) Whether the input is required.
         */
        "required"?: boolean;
        /**
          * (optional) Show a calendar icon. Note: Clicking on this icon will only emit an event `calendarIconClicked`.
         */
        "showCalendarIcon"?: boolean;
        /**
          * (optional) The input's size.
         */
        "size"?: 'medium' | 'large';
        /**
          * (optional) Denotes what type of date and the types are 'start','end','single'. Required when using `modus-date-picker`.
         */
        "type"?: ModusDateInputType;
        /**
          * (optional) The input's valid state text.
         */
        "validText"?: string;
        /**
          * (optional) A string representing the date entered to the input. The date is formatted according to ISO8601 'yyyy-mm-dd'. The displayed date format will differ from the 'value'.
         */
        "value"?: string;
    }
    interface ModusDatePicker {
        /**
          * (optional) Label for the field.
         */
        "label"?: string;
    }
    interface ModusDropdown {
        /**
          * Whether to apply list opening animation.
         */
        "animateList"?: boolean;
        /**
          * (optional) The dropdown's aria-label.
         */
        "ariaLabel"?: string | null;
        /**
          * (optional) Determines custom dropdown placement offset.
         */
        "customPlacement"?: {
    top?: number;
    right?: number;
    bottom?: number;
    left?: number;
  };
        /**
          * (optional) Disables the dropdown.
         */
        "disabled"?: boolean;
        /**
          * An event that fires on dropdown close.
         */
        "onDropdownClose"?: (event: ModusDropdownCustomEvent<any>) => void;
        /**
          * (optional) The placement of the dropdown in related to the toggleElement.
         */
        "placement"?: 'top' | 'right' | 'bottom' | 'left';
        /**
          * (optional) Whether to show the dropdown list's border.
         */
        "showDropdownListBorder"?: boolean;
        /**
          * (required) The element id that the list renders near and that triggers the toggling of the list.
         */
        "toggleElementId"?: string;
    }
    interface ModusFileDropzone {
        /**
          * (optional) The dropzone's aria-label.
         */
        "ariaLabel"?: string | null;
        /**
          * (optional) The dropzone's description text.
         */
        "description"?: string;
        /**
          * (optional) The dropzone's height.
         */
        "dropzoneHeight"?: string;
        /**
          * (optional) The dropzone's width.
         */
        "dropzoneWidth"?: string;
        /**
          * (optional) Whether to include the upload icon.
         */
        "includeStateIcon"?: boolean;
        /**
          * (optional) The dropzone's label text.
         */
        "label"?: string;
        /**
          * (optional) The dropzone's max file count.
         */
        "maxFileCount"?: number;
        /**
          * (optional) The dropzone's max file name length of each file.
         */
        "maxFileNameLength"?: number;
        /**
          * (optional) The dropzone's max total file size.
         */
        "maxTotalFileSizeBytes"?: number;
        /**
          * (optional) Whether multiple files can be uploaded.
         */
        "multiple"?: boolean;
        /**
          * An event that fires when files have been added or removed, regardless of whether they're valid.
         */
        "onFiles"?: (event: ModusFileDropzoneCustomEvent<[File[], string | null]>) => void;
    }
    interface ModusIcon {
        /**
          * (optional) The color of the Icon
         */
        "color"?: string;
        /**
          * The name of the icon
         */
        "name"?: ModusIconName | null;
        /**
          * (optional) The click handler function
         */
        "onIconClick"?: (event: ModusIconCustomEvent<any>) => void;
        /**
          * (optional) The size of the Icon
         */
        "size"?: string;
    }
    interface ModusList {
    }
    interface ModusListItem {
        /**
          * (optional) Whether the list item has a border or not
         */
        "borderless"?: boolean;
        /**
          * (optional) Disables the list item
         */
        "disabled"?: boolean;
        /**
          * (optional) Takes the icon name and shows the icon aligned to the left of the button text.
         */
        "leftIcon"?: string;
        /**
          * An event that fires on list item click
         */
        "onItemClick"?: (event: ModusListItemCustomEvent<any>) => void;
        /**
          * (optional) The selected state of the list item
         */
        "selected"?: boolean;
        /**
          * (optional) The size of list item
         */
        "size"?: 'condensed' | 'large' | 'standard';
        /**
          * (optional) Whether to show Subtext below the Slot content or not
         */
        "subText"?: string;
        /**
          * (optional) The type of list item
         */
        "type"?: string;
        /**
          * (optional) Whether to wrap the sub text.
         */
        "wrapSubText"?: true | false;
    }
    interface ModusMessage {
        /**
          * (optional) The message's aria-label.
         */
        "ariaLabel"?: string | null;
        /**
          * (optional) The message's icon.
         */
        "icon"?: string;
        /**
          * (optional) The message's type.
         */
        "type"?: 'info' | 'question';
    }
    interface ModusModal {
        /**
          * (optional) The modal's aria-label.
         */
        "ariaLabel"?: string | null;
        /**
          * (optional) The modal's backdrop. Specify 'static' for a backdrop that doesn't close the modal when clicked outside the modal content
         */
        "backdrop"?: 'default' | 'static';
        /**
          * (optional) The modal's primary button text.
         */
        "headerText"?: string;
        /**
          * An event that fires on modal close.
         */
        "onClosed"?: (event: ModusModalCustomEvent<any>) => void;
        /**
          * An event that fires on modal open.
         */
        "onOpened"?: (event: ModusModalCustomEvent<any>) => void;
        /**
          * An event that fires on primary button click.
         */
        "onPrimaryButtonClick"?: (event: ModusModalCustomEvent<any>) => void;
        /**
          * An event that fires on secondary button click.
         */
        "onSecondaryButtonClick"?: (event: ModusModalCustomEvent<any>) => void;
        /**
          * (optional) The modal's primary button aria-label.
         */
        "primaryButtonAriaLabel"?: string | null;
        /**
          * (optional) Disable primary button.
         */
        "primaryButtonDisabled"?: boolean;
        /**
          * (optional) The modal's primary button text.
         */
        "primaryButtonText"?: string;
        /**
          * (optional) The modal's secondary button aria-label.
         */
        "secondaryButtonAriaLabel"?: string | null;
        /**
          * (optional) Disable secondary button.
         */
        "secondaryButtonDisabled"?: boolean;
        /**
          * (optional) The modal's secondary button text.
         */
        "secondaryButtonText"?: string;
        /**
          * (optional) The modal's z-index.
         */
        "zIndex"?: string;
    }
    interface ModusNavbar {
        /**
          * (optional) The apps to render in the apps menu.
         */
        "apps"?: ModusNavbarApp[];
        /**
          * (optional) The buttons to render in the Navbar.
         */
        "buttons"?: ModusNavbarButton[];
        /**
          * (optional) Whether to show search overlay or not.
         */
        "enableSearchOverlay"?: boolean;
        /**
          * (optional) Help tooltip.
         */
        "helpTooltip"?: ModusNavbarTooltip;
        /**
          * (optional) Help URL.
         */
        "helpUrl"?: string;
        /**
          * (optional) Set the primary logo to display when the screen size is greater than 576 pixels, and the secondary logo to display when the screen size is less than or equal to 576 pixels.
         */
        "logoOptions"?: ModusNavbarLogoOptions;
        /**
          * An event that fires when an apps menu app opens.
         */
        "onAppsMenuAppOpen"?: (event: ModusNavbarCustomEvent<ModusNavbarApp>) => void;
        /**
          * An event that fires when the apps menu opens.
         */
        "onAppsMenuOpen"?: (event: ModusNavbarCustomEvent<void>) => void;
        /**
          * An event that fires when a button in the custom button list is clicked.
         */
        "onButtonClick"?: (event: ModusNavbarCustomEvent<string>) => void;
        /**
          * An event that fires when the help link opens.
         */
        "onHelpOpen"?: (event: ModusNavbarCustomEvent<void>) => void;
        /**
          * An event that fires on main menu click.
         */
        "onMainMenuClick"?: (event: ModusNavbarCustomEvent<KeyboardEvent | MouseEvent>) => void;
        /**
          * An event that fires when the notifications menu opens.
         */
        "onNotificationsMenuOpen"?: (event: ModusNavbarCustomEvent<void>) => void;
        /**
          * An event that fires on product logo click.
         */
        "onProductLogoClick"?: (event: ModusNavbarCustomEvent<MouseEvent>) => void;
        /**
          * An event that fires on profile menu link click.
         */
        "onProfileMenuLinkClick"?: (event: ModusNavbarCustomEvent<string>) => void;
        /**
          * An event that fires when the profile menu opens.
         */
        "onProfileMenuOpen"?: (event: ModusNavbarCustomEvent<void>) => void;
        /**
          * An event that fires on profile menu sign out click.
         */
        "onProfileMenuSignOutClick"?: (event: ModusNavbarCustomEvent<KeyboardEvent | MouseEvent>) => void;
        /**
          * An event that fires on search value change.
         */
        "onSearchChange"?: (event: ModusNavbarCustomEvent<string>) => void;
        /**
          * An event that fires on search button click.
         */
        "onSearchMenuClick"?: (event: ModusNavbarCustomEvent<void>) => void;
        /**
          * (required) Profile menu options.
         */
        "profileMenuOptions"?: ModusProfileMenuOptions;
        /**
          * (optional) Whether to display the navbar items in reverse order.
         */
        "reverse"?: boolean;
        /**
          * (optional) Search tooltip.
         */
        "searchTooltip"?: ModusNavbarTooltip;
        /**
          * (optional) Whether to show the apps menu.
         */
        "showAppsMenu"?: boolean;
        /**
          * (optional) Whether to show help.
         */
        "showHelp"?: boolean;
        /**
          * (optional) Whether to show the main menu.
         */
        "showMainMenu"?: boolean;
        /**
          * (optional) Whether to show notifications.
         */
        "showNotifications"?: boolean;
        /**
          * (optional) Whether to show the placeholder for Pendo.
         */
        "showPendoPlaceholder"?: boolean;
        /**
          * (optional) Whether to show profile.  *
         */
        "showProfile"?: boolean;
        /**
          * (optional) Whether to show search.
         */
        "showSearch"?: boolean;
        /**
          * (optional) Whether to show a shadow under the navbar.
         */
        "showShadow"?: boolean;
        /**
          * (optional) Color variants for NavBar.
         */
        "variant"?: 'default' | 'blue';
    }
    interface ModusNavbarAppsMenu {
        "apps"?: ModusNavbarApp1[];
        "onAppOpen"?: (event: ModusNavbarAppsMenuCustomEvent<ModusNavbarApp1>) => void;
        "reverse"?: boolean;
    }
    interface ModusNavbarButtonMenu {
        "reverse"?: boolean;
    }
    interface ModusNavbarMainMenu {
        "navbarId"?: string;
    }
    interface ModusNavbarNotificationsMenu {
        "reverse"?: boolean;
    }
    interface ModusNavbarProfileMenu {
        "avatarUrl"?: string;
        "email"?: string;
        "initials"?: string;
        "links"?: ModusNavbarProfileMenuLink[];
        "onLinkClick"?: (event: ModusNavbarProfileMenuCustomEvent<string>) => void;
        "onSignOutClick"?: (event: ModusNavbarProfileMenuCustomEvent<MouseEvent>) => void;
        "reverse"?: boolean;
        "signOutText"?: string;
        "username"?: string;
        "variant"?: 'default' | 'blue';
    }
    interface ModusNavbarSearchOverlay {
        /**
          * An event that fires on clicking on close button of search overlay
         */
        "onClose"?: (event: ModusNavbarSearchOverlayCustomEvent<void>) => void;
        /**
          * An event that fires on search value change.
         */
        "onSearch"?: (event: ModusNavbarSearchOverlayCustomEvent<string>) => void;
    }
    interface ModusNumberInput {
        /**
          * (optional) The input's aria-label.
         */
        "ariaLabel"?: string | null;
        /**
          * (optional) Whether the input is disabled.
         */
        "disabled"?: boolean;
        /**
          * (optional) The input's error state text.
         */
        "errorText"?: string;
        /**
          * (optional) The input's helper text displayed below the input.
         */
        "helperText"?: string;
        /**
          * (optional) The input's label.
         */
        "label"?: string;
        /**
          * (optional) The input's maximum value.
         */
        "maxValue"?: number;
        /**
          * (optional) The input's minimum value.
         */
        "minValue"?: number;
        /**
          * An event that fires on input value change.
         */
        "onValueChange"?: (event: ModusNumberInputCustomEvent<string>) => void;
        /**
          * (optional) The input's placeholder text.
         */
        "placeholder"?: string;
        /**
          * (optional) Whether the input's content is read-only
         */
        "readOnly"?: boolean;
        /**
          * (optional) Whether the input is required.
         */
        "required"?: boolean;
        /**
          * (optional) The input's size.
         */
        "size"?: 'medium' | 'large';
        /**
          * (optional) The input's step.
         */
        "step"?: number;
        /**
          * (optional) The input's text alignment.
         */
        "textAlign"?: 'left' | 'right';
        /**
          * (optional) The input's valid state text.
         */
        "validText"?: string;
        /**
          * (optional) The input's value.
         */
        "value"?: string;
    }
    interface ModusPagination {
        "activePage"?: number;
        "ariaLabel"?: string | null;
        "maxPage"?: number;
        "minPage"?: number;
        "nextPageButtonText"?: string;
        /**
          * An event that fires on page change.
         */
        "onPageChange"?: (event: ModusPaginationCustomEvent<number>) => void;
        "prevPageButtonText"?: string;
        "size"?: 'large' | 'medium' | 'small';
    }
    interface ModusProgressBar {
        /**
          * (optional) The progress bar's aria-label.
         */
        "ariaLabel"?: string | null;
        /**
          * (optional) The progress bar's background color.
         */
        "backgroundColor"?: string;
        /**
          * (optional) The progress bar's foreground color.
         */
        "color"?: string;
        /**
          * (optional) The progress bar's maximum value.
         */
        "maxValue"?: number;
        /**
          * (optional) The progress bar's minimum value.
         */
        "minValue"?: number;
        /**
          * (optional) The progress bar's size.
         */
        "size"?: 'default' | 'small' | 'compact';
        /**
          * (optional) The text displayed on the progress bar.
         */
        "text"?: string;
        /**
          * (optional) The progress bar's text color.
         */
        "textColor"?: string;
        /**
          * (optional) The progress bar's value.
         */
        "value"?: number;
    }
    interface ModusRadioGroup {
        /**
          * The radio group's aria-label.
         */
        "ariaLabel"?: string | null;
        /**
          * The ID of the checked radio button.
         */
        "checkedId"?: string;
        /**
          * The radio button group name.
         */
        "name"?: string;
        /**
          * Fires on radio button click.
         */
        "onButtonClick"?: (event: ModusRadioGroupCustomEvent<string>) => void;
        /**
          * The radio buttons to render.
         */
        "radioButtons"?: RadioButton[];
        /**
          * (optional) The size of the radiobutton.
         */
        "size"?: 'small' | 'medium';
    }
    interface ModusSelect {
        /**
          * (optional) The select's aria-label.
         */
        "ariaLabel"?: string | null;
        /**
          * (optional) Whether the input is disabled.
         */
        "disabled"?: boolean;
        /**
          * (optional) The input's error text.
         */
        "errorText"?: string;
        /**
          * (optional) The input's helper text.
         */
        "helperText"?: string;
        /**
          * (optional) The input label.
         */
        "label"?: string;
        /**
          * An event that fires on input blur.
         */
        "onInputBlur"?: (event: ModusSelectCustomEvent<FocusEvent>) => void;
        /**
          * An event that fires on input value change.
         */
        "onValueChange"?: (event: ModusSelectCustomEvent<unknown>) => void;
        /**
          * The options for the dropdown list.
         */
        "options"?: unknown[];
        /**
          * The options property to render in the dropdown list.
         */
        "optionsDisplayProp"?: string;
        /**
          * (optional) The input's placeholder.
         */
        "placeholder"?: string;
        /**
          * (optional) Whether the input is required.
         */
        "required"?: boolean;
        /**
          * (optional) The input's size.
         */
        "size"?: 'medium' | 'large';
        /**
          * (optional) The input's valid text.
         */
        "validText"?: string;
        /**
          * (optional) The input value.
         */
        "value"?: unknown;
    }
    interface ModusSentimentScale {
        /**
          * (optional) The sentiment scale's aria-label.
         */
        "ariaLabel"?: string | null;
        /**
          * (optional) Whether the sentiment scale is disabled.
         */
        "disabled"?: boolean;
        /**
          * An event that fires the selected sentiment.
         */
        "onSentimentSelection"?: (event: ModusSentimentScaleCustomEvent<any>) => void;
        /**
          * The type of icons to be displayed.
         */
        "type"?: ModusSentimentScaleType;
    }
    interface ModusSideNavigation {
        /**
          * (optional) To choose whether to collapse the panel when clicked outside.
         */
        "collapseOnClickOutside"?: boolean;
        /**
          * (optional) Data property to create the items.
         */
        "data"?: ModusSideNavigationItemInfo[];
        /**
          * (optional) The expanded state of side navigation panel and items.
         */
        "expanded"?: boolean;
        /**
          * (optional) Maximum width of the side navigation panel in an expanded state.
         */
        "maxWidth"?: string;
        /**
          * Mode to make side navigation either overlay or push the content for the selector specified in `targetContent`
         */
        "mode"?: 'overlay' | 'push';
        /**
          * An event that fires on side navigation panel collapse & expand.
         */
        "onSideNavExpand"?: (event: ModusSideNavigationCustomEvent<boolean>) => void;
        /**
          * (optional) Specify the selector for the page's content for which paddings and margins will be set by side navigation based on the `mode`.
         */
        "targetContent"?: string;
    }
    interface ModusSideNavigationItem {
        /**
          * (optional) Disables item selection.
         */
        "disableSelection"?: boolean;
        /**
          * (optional) The disabled state of side navigation panel item.
         */
        "disabled"?: boolean;
        "expanded"?: boolean;
        /**
          * (optional) Label for the item and the tooltip message.
         */
        "label"?: string;
        /**
          * (optional) A built-in menu icon string or a image url.
         */
        "menuIcon"?: string;
        /**
          * An event that fires when mouse click or `Enter` key press on an item.
         */
        "onSideNavItemClicked"?: (event: ModusSideNavigationItemCustomEvent<{ id: string; selected: boolean }>) => void;
        /**
          * An event that fires when an item is in focus.
         */
        "onSideNavItemFocus"?: (event: ModusSideNavigationItemCustomEvent<{ id: string }>) => void;
        "on_sideNavItemAdded"?: (event: ModusSideNavigationItemCustomEvent<HTMLElement>) => void;
        "on_sideNavItemRemoved"?: (event: ModusSideNavigationItemCustomEvent<HTMLElement>) => void;
        /**
          * (optional) The selected state of side navigation panel item.
         */
        "selected"?: boolean;
        /**
          * (optional) Shows the expand icon.
         */
        "showExpandIcon"?: boolean;
    }
    interface ModusSlider {
        /**
          * (optional) The slider's aria-label.
         */
        "ariaLabel"?: string | null;
        /**
          * (optional) Whether the slider is disabled. *
         */
        "disabled"?: boolean;
        /**
          * (optional) The slider's label.
         */
        "label"?: string;
        /**
          * (optional) The slider's maximum value.
         */
        "maxValue"?: number;
        /**
          * (optional) The slider's minimum value.
         */
        "minValue"?: number;
        /**
          * An event that fires on slider value change.
         */
        "onValueChange"?: (event: ModusSliderCustomEvent<string>) => void;
        /**
          * An event that fires on slider value input.
         */
        "onValueInput"?: (event: ModusSliderCustomEvent<string>) => void;
        /**
          * (optional) The slider's value.
         */
        "value"?: string;
    }
    interface ModusSpinner {
        /**
          * (optional) The color of the spinner. It can be a custom color or one of the variants  - primary, secondary, tertiary, dark, success, danger and warning.
         */
        "color"?: string;
        /**
          * (optional) The size of the spinner, will be applied to both the height and width
         */
        "size"?: string;
    }
    interface ModusSwitch {
        /**
          * (optional) The switch's aria-label.
         */
        "ariaLabel"?: string | null;
        /**
          * (optional) Whether the switch is checked.
         */
        "checked"?: boolean;
        /**
          * (optional) Whether the switch is disabled.
         */
        "disabled"?: boolean;
        /**
          * (optional) The switch label.
         */
        "label"?: string;
        /**
          * An event that fires on switch click.
         */
        "onSwitchClick"?: (event: ModusSwitchCustomEvent<boolean>) => void;
        /**
          * (optional) The size of the radiobutton.
         */
        "size"?: 'small' | 'medium';
    }
    interface ModusTable {
        /**
          * (Optional) To allow column reordering.
         */
        "columnReorder"?: boolean;
        "columnResize"?: boolean;
        /**
          * (Required) To display headers in the table.
         */
        "columns": ModusTableColumn<unknown>[];
        /**
          * (Required) To display data in the table.
         */
        "data": unknown[];
        /**
          * (Optional) To set the default sorting for the table.
         */
        "defaultSort"?: ModusTableColumnSort;
        /**
          * (optional) The density of the table.
         */
        "density"?: 'relaxed' | 'comfortable' | 'compact';
        /**
          * (Optional) To control display options of table.
         */
        "displayOptions"?: ModusTableDisplayOptions;
        "fullWidth"?: boolean;
        /**
          * (Optional) To enable row hover in table.
         */
        "hover"?: boolean;
        /**
          * (Optional) To enable manual pagination mode. When enabled, the table will not automatically paginate rows, instead will expect the current page index and other details to be passed.
         */
        "manualPaginationOptions"?: ModusTableManualPaginationOptions;
        /**
          * (Optional) To set modus-table in manual sorting mode.
         */
        "manualSortingOptions"?: ModusTableManualSortingOptions;
        /**
          * (Optional) To display a vertical scrollbar when the height is exceeded.
         */
        "maxHeight"?: string;
        /**
          * (Optional) To display a horizontal scrollbar when the width is exceeded.
         */
        "maxWidth"?: string;
        /**
          * Emits the link that was clicked
         */
        "onCellLinkClick"?: (event: ModusTableCustomEvent<ModusTableCellLink>) => void;
        /**
          * Emits the cell value that was edited
         */
        "onCellValueChange"?: (event: ModusTableCustomEvent<ModusTableCellValueChange>) => void;
        /**
          * Emits columns in the updated order
         */
        "onColumnOrderChange"?: (event: ModusTableCustomEvent<ModusTableColumnOrderState>) => void;
        /**
          * Emits latest column size
         */
        "onColumnSizingChange"?: (event: ModusTableCustomEvent<ModusTableColumnSizingState>) => void;
        /**
          * Emits visibility state of each column
         */
        "onColumnVisibilityChange"?: (event: ModusTableCustomEvent<ModusTableColumnVisibilityState>) => void;
        /**
          * Emits selected page index and size
         */
        "onPaginationChange"?: (event: ModusTableCustomEvent<ModusTablePaginationState>) => void;
        /**
          * An event that fires when a row action is clicked.
         */
        "onRowActionClick"?: (event: ModusTableCustomEvent<ModusTableRowActionClick>) => void;
        /**
          * Emits expanded state of the columns
         */
        "onRowExpanded"?: (event: ModusTableCustomEvent<ModusTableExpandedState>) => void;
        /**
          * Emits rows selected
         */
        "onRowSelectionChange"?: (event: ModusTableCustomEvent<unknown>) => void;
        /**
          * Emits column sort order
         */
        "onSortChange"?: (event: ModusTableCustomEvent<ModusTableSortingState>) => void;
        "pageSizeList"?: number[];
        "pagination"?: boolean;
        /**
          * (Optional) Actions that can be performed on each row. A maximum of 4 icons will be shown, including overflow menu and expand icons.
         */
        "rowActions"?: ModusTableRowAction[];
        /**
          * (Optional) To display checkbox.
         */
        "rowSelection"?: boolean;
        /**
          * (Optional) To control multiple row selection.
         */
        "rowSelectionOptions"?: ModusTableRowSelectionOptions;
        /**
          * (Optional) To display expanded rows.
         */
        "rowsExpandable"?: boolean;
        /**
          * (Optional) To display sort icon on hover.
         */
        "showSortIconOnHover"?: boolean;
        /**
          * (Optional) To sort data in table.
         */
        "sort"?: boolean;
        /**
          * (Optional) To display a-z or arrow sort icons.
         */
        "sortIconStyle"?: 'alphabetical' | 'directional';
        /**
          * (Optional) To display summary row.
         */
        "summaryRow"?: boolean;
        /**
          * (Optional) To display a toolbar for the table.
         */
        "toolbar"?: boolean;
        /**
          * (Optional) To display a toolbar, which allows access to table operations like hiding columns.
         */
        "toolbarOptions"?: ModusTableToolbarOptions | null;
        /**
          * (Optional) To wrap text that overflows the cell.
         */
        "wrapText"?: boolean;
    }
    interface ModusTableCellEditor {
        "args"?: ModusTableCellEditorArgs;
        "keyDown"?: (e: KeyboardEvent, newValue: string) => void;
        "type"?: string;
        "value"?: string;
        "valueChange"?: (newValue: string) => void;
    }
    interface ModusTableCellMain {
        "cell"?: Cell<unknown, unknown>;
        "context"?: TableContext;
        "hasRowsExpandable"?: boolean;
        "valueChange"?: (props: TableCellEdited) => void;
    }
    interface ModusTableColumnsVisibility {
        /**
          * Column visibility options
         */
        "columnsVisibility"?: ModusTableColumnsVisibilityOptions;
        /**
          * Table data.
         */
        "getAllLeafColumns"?: () => Column<unknown, unknown>[];
        "maxHeight"?: string;
        "menuIconContainerRef"?: HTMLDivElement;
        "showDropdown"?: boolean;
        "toggleDropdown"?: (show: boolean) => void;
    }
    interface ModusTableDropdownMenu {
        "context"?: TableContext;
    }
    /**
     * ModusFillerColumn is to fill empty space within a table or grid when the content in other columns is not wide enough to occupy the entire available width
     */
    interface ModusTableFillerColumn {
        "cellBorderless"?: boolean;
        "container"?: HTMLElement;
        "summaryRow"?: boolean;
    }
    interface ModusTableRowActions {
        "context"?: TableContext;
        "onOverflowRowActions"?: (event: ModusTableRowActionsCustomEvent<any>) => void;
        "row"?: Row<unknown>;
    }
    interface ModusTableRowActionsCell {
        "context"?: TableContext;
        "row"?: Row<unknown>;
    }
    interface ModusTableRowActionsMenu {
        "context"?: TableContext;
    }
    interface ModusTableToolbar {
        /**
          * Table data.
         */
        "context"?: TableContext;
    }
    interface ModusTabs {
        "ariaLabel"?: string | null;
        "fullWidth"?: boolean;
        /**
          * An event that fires on tab change.
         */
        "onTabChange"?: (event: ModusTabsCustomEvent<string>) => void;
        "size"?: 'medium' | 'small';
        /**
          * The tabs to render.
         */
        "tabs"?: Tab[];
    }
    interface ModusTextInput {
        /**
          * (optional) The input's aria-label.
         */
        "ariaLabel"?: string | null;
        /**
          * (optional) Sets autofocus on the input.
         */
        "autoFocusInput"?: boolean;
        /**
          * (optional) Sets autocomplete on the input.
         */
        "autocomplete"?: string | null;
        /**
          * (optional) Whether the input has a clear button.
         */
        "clearable"?: boolean;
        /**
          * (optional) Whether the input is disabled.
         */
        "disabled"?: boolean;
        /**
          * (optional) The input's error state text.
         */
        "errorText"?: string;
        /**
          * (optional) The input's helper text displayed below the input.
         */
        "helperText"?: string;
        /**
          * (optional) Whether the password text toggle icon is included.
         */
        "includePasswordTextToggle"?: boolean;
        /**
          * (optional) Whether the search icon is included.
         */
        "includeSearchIcon"?: boolean;
        /**
          * (optional) The input's inputmode.
         */
        "inputmode"?: 'decimal' | 'email' | 'numeric' | 'search' | 'tel' | 'text' | 'url';
        /**
          * (optional) The input's label.
         */
        "label"?: string;
        /**
          * (optional) The input's maximum length.
         */
        "maxLength"?: number;
        /**
          * (optional) The input's minimum length.
         */
        "minLength"?: number;
        /**
          * An event that fires on input value change.
         */
        "onValueChange"?: (event: ModusTextInputCustomEvent<string>) => void;
        /**
          * (optional) The input's pattern HTML attribute.
         */
        "pattern"?: string;
        /**
          * (optional) The input's placeholder text.
         */
        "placeholder"?: string;
        /**
          * (optional) Whether the input's content is read-only
         */
        "readOnly"?: boolean;
        /**
          * (optional) Whether the input is required.
         */
        "required"?: boolean;
        /**
          * (optional) The input's size.
         */
        "size"?: 'medium' | 'large';
        /**
          * (optional) The input's text alignment.
         */
        "textAlign"?: 'left' | 'right';
        /**
          * (optional) The input's type.
         */
        "type"?: 'email' | 'password' | 'search' | 'text' | 'tel' | 'url';
        /**
          * (optional) The input's valid state text.
         */
        "validText"?: string;
        /**
          * (optional) The input's value.
         */
        "value"?: string;
    }
    interface ModusTimePicker {
        /**
          * (optional) Regular expression to allow characters while typing the input. Default is `/[\d:apm\s]/gi` or `/[\d:]/gi` based on the display format.
         */
        "allowedCharsRegex"?: RegExp | string;
        /**
          * (optional) Sets 12/24 hour format for the input string.
         */
        "ampm"?: boolean;
        /**
          * (optional) The input's aria-label.
         */
        "ariaLabel"?: string | null;
        /**
          * (optional) Sets autofocus on the input.
         */
        "autoFocusInput"?: boolean;
        /**
          * (optional) Formats the text while typing in the input field.
         */
        "autoFormat"?: boolean;
        /**
          * (optional) Disables default validation for the time input.
         */
        "disableValidation"?: boolean;
        /**
          * (optional) Whether the input is disabled.
         */
        "disabled"?: boolean;
        /**
          * (optional) Custom error text displayed for the input.
         */
        "errorText"?: string;
        /**
          * (optional) Custom helper text displayed below the input.
         */
        "helperText"?: string;
        /**
          * (optional) The input's label.
         */
        "label"?: string;
        /**
          * (optional) Maximum time (in 24 hour format).
         */
        "max"?: string;
        /**
          * (optional) Minimum time (in 24 hour format).
         */
        "min"?: string;
        /**
          * An event that fires on input value out of focus.
         */
        "onTimeInputBlur"?: (event: ModusTimePickerCustomEvent<ModusTimePickerEventDetails>) => void;
        /**
          * An event that fires on input value change.
         */
        "onValueChange"?: (event: ModusTimePickerCustomEvent<ModusTimePickerEventDetails>) => void;
        /**
          * (optional) The input's placeholder text.
         */
        "placeholder"?: string;
        /**
          * (optional) Whether the input's content is read-only
         */
        "readOnly"?: boolean;
        /**
          * (optional) Whether the input is required.
         */
        "required"?: boolean;
        /**
          * (optional) The input's size.
         */
        "size"?: 'medium' | 'large';
        /**
          * (optional) The input's valid state text.
         */
        "validText"?: string;
        /**
          * (optional) Value of the time entered into the input.
         */
        "value"?: string;
    }
    interface ModusToast {
        /**
          * (optional) The toast's aria-label.
         */
        "ariaLabel"?: string | null;
        /**
          * (optional) Whether the toast has a dismiss button.
         */
        "dismissible"?: boolean;
        /**
          * An event that fires when the toast is dismissed
         */
        "onDismissClick"?: (event: ModusToastCustomEvent<any>) => void;
        /**
          * (optional) Whether to show the toasts' icon.
         */
        "showIcon"?: boolean;
        /**
          * (optional) The toasts' type.
         */
        "type"?: 'danger' | 'dark' | 'default' | 'primary' | 'secondary' | 'success' | 'warning';
    }
    interface ModusTooltip {
        /**
          * (optional) The tooltip's aria-label.
         */
        "ariaLabel"?: string | null;
        /**
          * Hide the tooltip
         */
        "disabled"?: boolean;
        /**
          * (optional) The tooltip's position relative to its content.
         */
        "position"?: ModusToolTipPlacement;
        /**
          * The tooltip's text.
         */
        "text"?: string;
    }
    interface ModusTreeView {
        /**
          * (optional) Whether the content tree and items have a border or not
         */
        "borderless"?: boolean;
        /**
          * (optional) Enables checkbox selection on each tree item
         */
        "checkboxSelection"?: boolean;
        /**
          * (optional) Set checked tree items
         */
        "checkedItems"?: string[];
        /**
          * (optional) Disable usage of `tab` key to focus elements inside a tree view. Use `Arrow Up/Down` for focussing a tree item and `Shift + Arrow Right` for focussing a checkbox inside the item.
         */
        "disableTabbing"?: boolean;
        /**
          * (optional) Set expanded tree items
         */
        "expandedItems"?: string[];
        /**
          * (optional) Enables multiple checkbox selection
         */
        "multiCheckboxSelection"?: boolean;
        /**
          * (optional) Enables multiple tree items selection
         */
        "multiSelection"?: boolean;
        /**
          * Fired when an action is clicked within any tree item. Includes both the `actionId` and `nodeId` of the action and item, respectively.
         */
        "onItemActionClick"?: (event: ModusTreeViewCustomEvent<any>) => void;
        /**
          * (optional) Set selected tree items
         */
        "selectedItems"?: string[];
        /**
          * (optional) The default size of all tree items
         */
        "size"?: 'condensed' | 'large' | 'standard';
    }
    interface ModusTreeViewItem {
        /**
          * (optional) Actions that can be performed on each item. A maximum of 3 icons will be shown, including overflow menu and expand icons.
         */
        "actions"?: ModusActionBarOptions1[];
        /**
          * (optional) Disables the tree item
         */
        "disabled"?: boolean;
        /**
          * (optional) Allows the item to be dragged across the tree
         */
        "draggableItem"?: boolean;
        /**
          * (optional) Allows the item to be a drop zone so other tree items can be dropped above it
         */
        "droppableItem"?: boolean;
        /**
          * (optional) Changes the label field into a text box
         */
        "editable"?: boolean;
        /**
          * (required) Label for the tree item
         */
        "label": string;
        /**
          * (required) Unique tree item identifier
         */
        "nodeId": string;
        /**
          * Fired when an action button within the tree item is clicked. Includes the `actionId`.
         */
        "onActionClick"?: (event: ModusTreeViewItemCustomEvent<any>) => void;
        /**
          * An event that fires on tree item checkbox click
         */
        "onCheckboxClick"?: (event: ModusTreeViewItemCustomEvent<boolean>) => void;
        "onItemAdded"?: (event: ModusTreeViewItemCustomEvent<HTMLElement>) => void;
        /**
          * An event that fires on tree item click
         */
        "onItemClick"?: (event: ModusTreeViewItemCustomEvent<boolean>) => void;
        /**
          * An event that fires on tree item expand/collapse
         */
        "onItemExpandToggle"?: (event: ModusTreeViewItemCustomEvent<boolean>) => void;
        /**
          * (optional) Tab Index for the tree item
         */
        "tabIndexValue"?: string | number;
    }
    interface IntrinsicElements {
        "modus-accordion": ModusAccordion;
        "modus-accordion-item": ModusAccordionItem;
        "modus-action-bar": ModusActionBar;
        "modus-alert": ModusAlert;
        "modus-autocomplete": ModusAutocomplete;
        "modus-badge": ModusBadge;
        "modus-breadcrumb": ModusBreadcrumb;
        "modus-button": ModusButton;
        "modus-card": ModusCard;
        "modus-checkbox": ModusCheckbox;
        "modus-chip": ModusChip;
        "modus-data-table": ModusDataTable;
        "modus-date-input": ModusDateInput;
        "modus-date-picker": ModusDatePicker;
        "modus-dropdown": ModusDropdown;
        "modus-file-dropzone": ModusFileDropzone;
        "modus-icon": ModusIcon;
        "modus-list": ModusList;
        "modus-list-item": ModusListItem;
        "modus-message": ModusMessage;
        "modus-modal": ModusModal;
        "modus-navbar": ModusNavbar;
        "modus-navbar-apps-menu": ModusNavbarAppsMenu;
        "modus-navbar-button-menu": ModusNavbarButtonMenu;
        "modus-navbar-main-menu": ModusNavbarMainMenu;
        "modus-navbar-notifications-menu": ModusNavbarNotificationsMenu;
        "modus-navbar-profile-menu": ModusNavbarProfileMenu;
        "modus-navbar-search-overlay": ModusNavbarSearchOverlay;
        "modus-number-input": ModusNumberInput;
        "modus-pagination": ModusPagination;
        "modus-progress-bar": ModusProgressBar;
        "modus-radio-group": ModusRadioGroup;
        "modus-select": ModusSelect;
        "modus-sentiment-scale": ModusSentimentScale;
        "modus-side-navigation": ModusSideNavigation;
        "modus-side-navigation-item": ModusSideNavigationItem;
        "modus-slider": ModusSlider;
        "modus-spinner": ModusSpinner;
        "modus-switch": ModusSwitch;
        "modus-table": ModusTable;
        "modus-table-cell-editor": ModusTableCellEditor;
        "modus-table-cell-main": ModusTableCellMain;
        "modus-table-columns-visibility": ModusTableColumnsVisibility;
        "modus-table-dropdown-menu": ModusTableDropdownMenu;
        "modus-table-filler-column": ModusTableFillerColumn;
        "modus-table-row-actions": ModusTableRowActions;
        "modus-table-row-actions-cell": ModusTableRowActionsCell;
        "modus-table-row-actions-menu": ModusTableRowActionsMenu;
        "modus-table-toolbar": ModusTableToolbar;
        "modus-tabs": ModusTabs;
        "modus-text-input": ModusTextInput;
        "modus-time-picker": ModusTimePicker;
        "modus-toast": ModusToast;
        "modus-tooltip": ModusTooltip;
        "modus-tree-view": ModusTreeView;
        "modus-tree-view-item": ModusTreeViewItem;
    }
}
export { LocalJSX as JSX };
declare module "@stencil/core" {
    export namespace JSX {
        interface IntrinsicElements {
            "modus-accordion": LocalJSX.ModusAccordion & JSXBase.HTMLAttributes<HTMLModusAccordionElement>;
            "modus-accordion-item": LocalJSX.ModusAccordionItem & JSXBase.HTMLAttributes<HTMLModusAccordionItemElement>;
            "modus-action-bar": LocalJSX.ModusActionBar & JSXBase.HTMLAttributes<HTMLModusActionBarElement>;
            "modus-alert": LocalJSX.ModusAlert & JSXBase.HTMLAttributes<HTMLModusAlertElement>;
            "modus-autocomplete": LocalJSX.ModusAutocomplete & JSXBase.HTMLAttributes<HTMLModusAutocompleteElement>;
            "modus-badge": LocalJSX.ModusBadge & JSXBase.HTMLAttributes<HTMLModusBadgeElement>;
            "modus-breadcrumb": LocalJSX.ModusBreadcrumb & JSXBase.HTMLAttributes<HTMLModusBreadcrumbElement>;
            "modus-button": LocalJSX.ModusButton & JSXBase.HTMLAttributes<HTMLModusButtonElement>;
            "modus-card": LocalJSX.ModusCard & JSXBase.HTMLAttributes<HTMLModusCardElement>;
            "modus-checkbox": LocalJSX.ModusCheckbox & JSXBase.HTMLAttributes<HTMLModusCheckboxElement>;
            "modus-chip": LocalJSX.ModusChip & JSXBase.HTMLAttributes<HTMLModusChipElement>;
            "modus-data-table": LocalJSX.ModusDataTable & JSXBase.HTMLAttributes<HTMLModusDataTableElement>;
            "modus-date-input": LocalJSX.ModusDateInput & JSXBase.HTMLAttributes<HTMLModusDateInputElement>;
            "modus-date-picker": LocalJSX.ModusDatePicker & JSXBase.HTMLAttributes<HTMLModusDatePickerElement>;
            "modus-dropdown": LocalJSX.ModusDropdown & JSXBase.HTMLAttributes<HTMLModusDropdownElement>;
            "modus-file-dropzone": LocalJSX.ModusFileDropzone & JSXBase.HTMLAttributes<HTMLModusFileDropzoneElement>;
            "modus-icon": LocalJSX.ModusIcon & JSXBase.HTMLAttributes<HTMLModusIconElement>;
            "modus-list": LocalJSX.ModusList & JSXBase.HTMLAttributes<HTMLModusListElement>;
            "modus-list-item": LocalJSX.ModusListItem & JSXBase.HTMLAttributes<HTMLModusListItemElement>;
            "modus-message": LocalJSX.ModusMessage & JSXBase.HTMLAttributes<HTMLModusMessageElement>;
            "modus-modal": LocalJSX.ModusModal & JSXBase.HTMLAttributes<HTMLModusModalElement>;
            "modus-navbar": LocalJSX.ModusNavbar & JSXBase.HTMLAttributes<HTMLModusNavbarElement>;
            "modus-navbar-apps-menu": LocalJSX.ModusNavbarAppsMenu & JSXBase.HTMLAttributes<HTMLModusNavbarAppsMenuElement>;
            "modus-navbar-button-menu": LocalJSX.ModusNavbarButtonMenu & JSXBase.HTMLAttributes<HTMLModusNavbarButtonMenuElement>;
            "modus-navbar-main-menu": LocalJSX.ModusNavbarMainMenu & JSXBase.HTMLAttributes<HTMLModusNavbarMainMenuElement>;
            "modus-navbar-notifications-menu": LocalJSX.ModusNavbarNotificationsMenu & JSXBase.HTMLAttributes<HTMLModusNavbarNotificationsMenuElement>;
            "modus-navbar-profile-menu": LocalJSX.ModusNavbarProfileMenu & JSXBase.HTMLAttributes<HTMLModusNavbarProfileMenuElement>;
            "modus-navbar-search-overlay": LocalJSX.ModusNavbarSearchOverlay & JSXBase.HTMLAttributes<HTMLModusNavbarSearchOverlayElement>;
            "modus-number-input": LocalJSX.ModusNumberInput & JSXBase.HTMLAttributes<HTMLModusNumberInputElement>;
            "modus-pagination": LocalJSX.ModusPagination & JSXBase.HTMLAttributes<HTMLModusPaginationElement>;
            "modus-progress-bar": LocalJSX.ModusProgressBar & JSXBase.HTMLAttributes<HTMLModusProgressBarElement>;
            "modus-radio-group": LocalJSX.ModusRadioGroup & JSXBase.HTMLAttributes<HTMLModusRadioGroupElement>;
            "modus-select": LocalJSX.ModusSelect & JSXBase.HTMLAttributes<HTMLModusSelectElement>;
            "modus-sentiment-scale": LocalJSX.ModusSentimentScale & JSXBase.HTMLAttributes<HTMLModusSentimentScaleElement>;
            "modus-side-navigation": LocalJSX.ModusSideNavigation & JSXBase.HTMLAttributes<HTMLModusSideNavigationElement>;
            "modus-side-navigation-item": LocalJSX.ModusSideNavigationItem & JSXBase.HTMLAttributes<HTMLModusSideNavigationItemElement>;
            "modus-slider": LocalJSX.ModusSlider & JSXBase.HTMLAttributes<HTMLModusSliderElement>;
            "modus-spinner": LocalJSX.ModusSpinner & JSXBase.HTMLAttributes<HTMLModusSpinnerElement>;
            "modus-switch": LocalJSX.ModusSwitch & JSXBase.HTMLAttributes<HTMLModusSwitchElement>;
            "modus-table": LocalJSX.ModusTable & JSXBase.HTMLAttributes<HTMLModusTableElement>;
            "modus-table-cell-editor": LocalJSX.ModusTableCellEditor & JSXBase.HTMLAttributes<HTMLModusTableCellEditorElement>;
            "modus-table-cell-main": LocalJSX.ModusTableCellMain & JSXBase.HTMLAttributes<HTMLModusTableCellMainElement>;
            "modus-table-columns-visibility": LocalJSX.ModusTableColumnsVisibility & JSXBase.HTMLAttributes<HTMLModusTableColumnsVisibilityElement>;
            "modus-table-dropdown-menu": LocalJSX.ModusTableDropdownMenu & JSXBase.HTMLAttributes<HTMLModusTableDropdownMenuElement>;
            /**
             * ModusFillerColumn is to fill empty space within a table or grid when the content in other columns is not wide enough to occupy the entire available width
             */
            "modus-table-filler-column": LocalJSX.ModusTableFillerColumn & JSXBase.HTMLAttributes<HTMLModusTableFillerColumnElement>;
            "modus-table-row-actions": LocalJSX.ModusTableRowActions & JSXBase.HTMLAttributes<HTMLModusTableRowActionsElement>;
            "modus-table-row-actions-cell": LocalJSX.ModusTableRowActionsCell & JSXBase.HTMLAttributes<HTMLModusTableRowActionsCellElement>;
            "modus-table-row-actions-menu": LocalJSX.ModusTableRowActionsMenu & JSXBase.HTMLAttributes<HTMLModusTableRowActionsMenuElement>;
            "modus-table-toolbar": LocalJSX.ModusTableToolbar & JSXBase.HTMLAttributes<HTMLModusTableToolbarElement>;
            "modus-tabs": LocalJSX.ModusTabs & JSXBase.HTMLAttributes<HTMLModusTabsElement>;
            "modus-text-input": LocalJSX.ModusTextInput & JSXBase.HTMLAttributes<HTMLModusTextInputElement>;
            "modus-time-picker": LocalJSX.ModusTimePicker & JSXBase.HTMLAttributes<HTMLModusTimePickerElement>;
            "modus-toast": LocalJSX.ModusToast & JSXBase.HTMLAttributes<HTMLModusToastElement>;
            "modus-tooltip": LocalJSX.ModusTooltip & JSXBase.HTMLAttributes<HTMLModusTooltipElement>;
            "modus-tree-view": LocalJSX.ModusTreeView & JSXBase.HTMLAttributes<HTMLModusTreeViewElement>;
            "modus-tree-view-item": LocalJSX.ModusTreeViewItem & JSXBase.HTMLAttributes<HTMLModusTreeViewItemElement>;
        }
    }
}
